# suppress inspection "UnusedProperty" for whole file

# Members and Names

member.named=%1$s '%2$s'

member.header=header
member.typealias=type alias

member.class=class
member.interface=interface
member.trait=trait
member.annotation=annotation class
member.enum=enum class
member.object=object class

member.method=method
member.constructor=constructor
member.initializer=initializer
member.field=field
member.property=property
member.property.setter=property setter
member.property.getter=property getter

member.parameter=parameter
member.classparameter=class parameter
member.variable=variable
member.typeparameter=type parameter

# Resolution

resolve.any='%s' could not be resolved to a type, method or field
resolve.package='%s' could not be resolved to a package or class
resolve.header='%s' could not be resolved to a header file
resolve.type='%s' could not be resolved to a type
resolve.type.package='%1$s' could not be resolved to a type in '%2$s'
resolve.field='%s' could not be resolved to a field
resolve.label='%s' could not be resolved to a label

# Headers

package_declaration.missing=missing package declaration in non-default package '%s'
package_declaration.mismatch=package declaration '%s' does not match enclosing package '%s'
package_declaration.default_package=package declaration '%s' is not allowed in default package

import.invalid=invalid import declaration
import.resolve='%s' could not be resolved
import.inline_header.internal=the internal header '%s' cannot be included because it is private to it's library
import.inline_header.invisible=the header '%s' cannot be included because it is not visible

header.name.mismatch=invalid header declaration - mismatching names
header.name=header name: %s
header.declaration.name=header declaration name: %s

typealias.invalid=invalid type alias - type expected

# Type Parameters

type_parameter.bound.class=type parameters can only have one bound that is a class
type_parameter.declaration=type parameter: %s

# Types

type.access.invisible=the type '%s' cannot be accessed because it is not visible
type.access.internal=the internal class '%s' cannot be accessed because it is private to it's library
type.access.invalid=the instance of the type '%s' cannot be accessed because it is not an object type

type.annotated.invalid=invalid annotated type - type expected
type.wildcard.invalid=wildcard types cannot be used at this location

type.array.void=array types cannot wrap the type 'void'
type.array.super=array types cannot be used as super types

type.lambda.class=lambda types cannot be used at this location
type.lambda.return=invalid lambda type - missing return type

type.var.super=the type variable '%s' cannot be used as a super type
type.var.class=the un-reified type parameter '%s' cannot be used where a class type is expected
type.var.covariant=the covariant type parameter '%s' cannot be used in contravariant position
type.var.contravariant=the contravariant type parameter '%s' cannot be used in covariant position

type.alias.unresolved=the referenced type alias '%s' did not resolve correctly

type.dimensions=type dimensions: %d
type.expected=expected type: %s
type.enclosing=enclosing type: %s

## Generic Types

type.generic.class=generic types cannot be used at this location
type.generic.package.not_generic=the package '%s' cannot be parameterized
type.generic.class.not_generic=the non-generic class '%s' cannot be parameterized
type.generic.class.count_mismatch=mismatching number of generic type arguments and type parameters of class '%s'
type.generic.type_parameter.not_generic=the type parameter '%s' cannot be parameterized
type.generic.type_alias.count_mismatch=mismatching number of generic type arguments and type parameters of type alias '%s'

type.generic.count=invalid number of generic type arguments
type.generic.incompatible=the generic type argument is incompatible with the type variable '%1$s' (in class %2$s)

type.generic.argument=generic type argument: %s
type.generic.parameter_count=type parameter count: %d
type.generic.argument_count=type argument count: %d

# Annotations

annotation.type=the type '%s' is not an annotation type
annotation.type.invalid=invalid annotation - missing annotation type
annotation.target=the annotation type '%s' is not applicable for the target
annotation.target.element=element target type: %s
annotation.target.allowed=allowed target types: %s
annotation.method='%2$s' could not be resolved to an annotation interface method for '%1$s'
annotation.constant=the value for '%s' has to be a constant expression
annotation.parameter.missing=the annotation of type '%1$s' does not provide a value for the non-default parameter '%2$s'
annotation.parameter.type=the value for '%s' is incompatible with the required type
annotation.array.not_constant=the array element cannot be converted to a compile-time constant
annotation.field.not_constant=the field '%1$s' cannot be folded to a compile-time constant

# -- Classes --

class.extend.type=the %1$s '%2$s' cannot be extended, only classes are allowed
class.extend.final=the final class '%s' cannot be extended
class.extend.internal=the internal class '%s' cannot be extended
class.implement.type=the %1$s '%2$s' cannot be implemented, only interfaces are allowed
class.implement.internal=the internal interface '%s' cannot be extended
class.object.constructor=the object class '%s' cannot have a constructor
class.method.abstract=the type '%1$s' doesn't override the abstract method '%2$s' of the super type '%3$s'
class.method.conflict=conflicting interface method '%1$s' in direct super-interfaces of class '%2$s', override this method
class.inner.not_static=the inner class '%1$s' should use the 'static' modifier

class.descriptor.duplicate=the class '%s' does not have a unique descriptor '%s'
class.descriptor.duplicate.nested=the class '%1$s' does not have a unique descriptor '%3$s' in the enclosing class '%2$s'
class.descriptor.duplicate.header=the class '%1$s' does not have a unique descriptor '%3$s' in the enclosing header '%2$s'
class.descriptor.duplicate.package=the class '%1$s' does not have a unique descriptor '%3$s' in the enclosing package '%2$s'
class.descriptor.duplicate.external=the class '%1$s' has the descriptor '%3$s' which already exists in a library

class.object.field=the object class '%s' cannot declare a field named 'instance'

trait.field.warning=the field '%s' is implicitly public, static and final in a trait

interface.property.initializer=properties in interfaces cannot declare property initializers
interface.classparameters=interfaces and traits cannot declare class parameters
interface.constructor=interfaces and traits cannot declare constructors
interface.initializer=interfaces cannot declare initializers

interface.functional.not_found=the functional interface '%s' does not have an abstract method
interface.functional.multiple=the functional interface '%s' has multiple abstract methods
interface.functional.class=the functionalinterface annotation can only be applied to interfaces and traits

enum.super_class=enums must not have super types, only interfaces can be inherited from

extension.generic=invalid extension class - extension classes cannot be generic
extension.field.invalid=invalid field - extension classes can only contain 'private const' fields

# Class Parameters

classparameter.type=class parameter type: %s
classparameter.type.incompatible=the default value of the class parameter '%s' is incompatible with the parameter type
classparameter.type.infer=the type of the class parameter '%s' could not be inferred
classparameter.type.void=class parameters cannot have the type void

classparameter.override.not_found=the class parameter '%s' does not override a field from a super-class
classparameter.override.static=the class parameter '%1$s' overrides the static field '%1$s' from class '%2$s'
classparameter.override.property=the class parameter '%1$s' marked as 'override' must not have an associated property

classparameter.access.instance=the class parameter '%s' cannot be accessed from a static context
classparameter.access.unqualified=the class parameter '%s' should be qualified with 'this'
classparameter.assign.final=the final class parameter '%s' cannot be assigned
classparameter.assign.type=the type of the assigned value is incompatible with the type of the class parameter '%s'
classparameter.assign.annotation=the annotation parameter '%s' cannot be assigned

# -- Members --

# Modifiers

modifiers.visibility.default=the %1$s does not need to explicitly declare default visibility '%2$s'
modifiers.illegal=the %1$s has illegal modifiers: %2$s
modifiers.visibility.illegal=the %1$s has an illegal combination of visibility modifiers: %2$s
modifiers.native.implemented=the %1$s cannot be declared native if it has an implementation
modifiers.native.abstract=the %1$s cannot be declared both native and abstract
modifiers.abstract.implemented=the %1$s cannot be declared abstract if it has an implementation
modifiers.abstract.concrete_class=the %1$s cannot be declared abstract as a member of the concrete type %2$s
modifiers.unimplemented=the %1$s is not implemented, but does not have an abstract modifier

# Access

access.invisible=the %2$s %1$s cannot be accessed because it is not visible
access.internal=the internal %s cannot be accessed because it is private to it's library

# Initializers

initializer.type=the block of an initializer has to be usable as a statement

# Constructors

constructor.abstract=the constructor does not have an implementation
constructor.static=constructors cannot be declared static
constructor.typevar.infer=the type argument for the type variable '%2$s' of the class '%1$s' was inferred to %3$s
constructor.typevar.incompatible=the type argument for the type variable '%2$s' of the class '%1$s' is incompatible with \
it's bounds

constructor.access.type.missing=invalid constructor - missing type
constructor.access.resolve=the constructor for '%s' could not be resolved
constructor.access.ambiguous=ambiguous call to constructor of class '%s'
constructor.access.abstract=the abstract class '%s' cannot be instantiated
constructor.access.interface=the interface '%s' cannot be instantiated
constructor.access.internal=the internal constructor for '%s' cannot be accessed because it is private to it's library
constructor.access.array.length=the number of array length parameters exceeds the type dimensions
constructor.access.array.count=number of length parameters: %d
constructor.access.array.type=the array length parameter has to be of type int
constructor.access.array.typevar=cannot create an array of the generic type parameter %s

# -- Methods --

method.duplicate.descriptor=duplicate method '%s' with descriptor '%s%s'
method.type=method return type: %s
method.type.incompatible=the return value of the method '%s' is incompatible with the return type
method.exception.type=the thrown exception must be a subtype of java.lang.throwable

method.this_type.incompatible=the receiver type of the method '%s' is incompatible with the enclosing class
method.this_type=explicit 'this' type: %s
method.enclosing_class=enclosing class type: %s

# - Override Checks -
method.override.notfound=the method '%s' must override or implement a supertype method
method.overrides=the method '%s' overrides a method, but does not have an 'override' modifier

# Override Visibility
method.visibility=method visibility: %s
method.override.final=the method '%s' cannot override a final method
method.override.private=the method '%s' cannot override a private method
method.override.visibility=overridden method visibility: %s
method.override.visibility.mismatch=the method '%s' cannot reduce the visibility of the overridden method

# Override Type
method.override=overriden method: %s (in %s)
method.override.parameter_label=the parameter label '%2$s' differs from the overridden methods label '%3$s' for parameter #%1$d
method.override.mangled_mismatch=the method '%1$s' does not override the method '%1$s' because the latter uses a \
  different, custom bytecode name '%2$s'
method.override.mangled_mismatch.info=add '@bytecodename('%1$s')' to use the same bytecode name
method.override.mangled_clash=the method '%1$s' does not override the method '%2$s', but uses the same bytecode name '%3$s'
method.override.mangled_clash.info=add '@automangled' or '@bytecodename(custom name)' to use a different bytecode name
method.override.type=overriden return type: %s
method.override.type.incompatible=the return type of the method '%s' is incompatible with the overridden method type

method.typevar.infer=the type argument for the type variable '%2$s' of the method '%1$s' was inferred to %3$s
method.typevar.incompatible=the type argument for the type variable '%2$s' of the method '%1$s' is incompatible with \
  it's bounds

method.access.static=the static method '%s' must be accessed in a static way
method.access.static.type=the static method '%1$s' of type '%2$s' should be accessed from that type
method.access.instance=the instance method '%s' cannot be accessed from a static context
method.access.unqualified=the instance method '%s' should be qualified with 'this'
method.access.infix_type=the infix method argument for '%s' is incompatible with the required type
method.access.receiver_type=the receiver for the instance method '%s' is incompatible with the required receiver type
method.access.prefix_type=the prefix method argument for '%s' is incompatible with the required type
method.access.argument_type=the method argument for '%s' is incompatible with the required type
method.access.argument.missing=missing argument for parameter '%1$s'
method.access.argument.implicit=missing implicit value for parameter '%1$s' of type '%2$s'
method.access.argument.empty=missing argument for parameter '%s' cannot be inferred without explicit argument list
method.access.argument.empty.info=add the empty argument list () at the end of the method call to fix
method.access.resolve='%s' could not be resolved to a method
method.access.resolve.field='%s' could not be resolved to a method or field
method.access.ambiguous=ambiguous call to method '%s'
method.access.unresolved_type=the type of the method '%s' is unresolved

method.access.argument_types=argument types: %s
method.access.candidates=candidates:

method.nested.access.early=the nested method '%s' cannot be used before it is declared
method.nested.not_private=the nested method '%s' has to be 'private', '%s' is not allowed

method.extension.this_type.invalid=the extension method '%s' must define a this type - add 'this: sometype' as the first parameter

method.not_symbolic.deprecated=non-symbolic prefix, infix and postfix functions are deprecated
method.not_symbolic.deprecated.fix=use an instance or extension method instead

method.prefix.not_1_parameter.deprecated=prefix functions with more or less than one parameter are deprecated
method.infix.not_2_parameters.deprecated=infix functions with more or less than two parameters are deprecated
method.postfix.not_1_parameter.deprecated=postfix functions with more or less than one parameter are deprecated

# Parameters

parameter.type=parameter type: %s
parameter.type.incompatible=the default value of the parameter '%s' is incompatible with the parameter type
parameter.type.infer=the type of the parameter '%s' could not be inferred
parameter.type.void=parameters cannot have the type void
parameter.varargs.incompatible=the type of the varargs parameter '%s' is not convertible from an array expression

parameter.assign.final=the final parameter '%s' cannot be assigned
parameter.assign.type=the type of the assigned value is incompatible with the type of the parameter '%s'

arguments.duplicate.label=duplicate parameter label '%s'

# Properties

property.initializer.type=the initializer of a property has to be usable as a statement
property.type.infer=the type of the property '%s' could not be inferred
property.empty=the property '%s' cannot have neither a getter nor a setter
property.type.void=the property '%s' cannot have the type 'void'

# Fields

field.type=field type: %s
field.type.incompatible=the initial value of the field '%s' is incompatible with the field type
field.type.infer=the type of the field '%s' could not be inferred
field.type.infer.novalue=the type of the uninitialized field '%s' could not be inferred
field.type.void=fields cannot have the type void
field.type.no_default=the type of the uninitialized field '%s' does not have a default value
field.property.setter.final=the final field '%s' cannot define a default property setter
field.enum.class=the enclosing class of the enum constant '%s' must be an enum class
field.enum.type.incompatible=the type of the enum constant '%s' must be a sub-type of the enclosing class type

field.access.invisible=the field '%s' cannot be accessed because it is not visible
field.access.internal=the internal field '%s' cannot be accessed because it is private to it's library
field.access.instance=the instance field '%s' cannot be accessed from a static context
field.access.static=the static field '%s' must be accessed in a static way
field.access.static.type=the static field '%1$s' of type '%2$s' should be accessed from that type
field.access.receiver_type=the receiver for the instance field '%s' incompatible with the required receiver type
field.access.unqualified=the instance field '%s' should be qualified with 'this'
field.access.unresolved_type=the type of the field '%s' is unresolved
field.assign.type=the type of the assigned value is incompatible with the type of the field '%s'
field.assign.final=the final field '%s' cannot be assigned

# Variables

variable.uninitialized=the variable '%s' has to be declared with an initial value
variable.shadow=the variable '%s' shadows another variable with the same name declared earlier
variable.type=variable type: %s
variable.type.incompatible=the initial value of the variable '%s' is incompatible with the variable type
variable.type.infer=the type of the variable '%s' could not be inferred
variable.type.void=variables cannot have the type void
variable.assign.type=the type of the assigned value is incompatible with the type of the variable '%s'
variable.assign.final=the final variable '%s' cannot be assigned

variable.access.capture=the parameter '%s' cannot be accessed in this context because it is neither final nor \
  effectively final and cannot be converted to a reference variable
variable.assign.capture=the parameter '%s' cannot be assigned as it cannot be converted to a reference variable

# References

reference.expression.invalid=the expression cannot be referenced
reference.field.final=the final field '%s' cannot be converted to a reference
reference.property.no_setter=the property '%s' cannot be converted to a reference because it doesn't have a setter
reference.variable.invalid=the %s cannot be converted to a reference
reference.variable.assignment=the %s cannot be assigned because it cannot be converted to a reference

# Deprecation

deprecated.since=deprecated since: %s
deprecated.forRemoval=scheduled for removal: %s
deprecated.description=description: %s
deprecated.replacements=replacements:
deprecated.reason=reason: %s
deprecated.reasons=reasons: %s
deprecated.reason.DANGEROUS=dangerous
deprecated.reason.CONDEMNED=condemned
deprecated.reason.SUPERSEDED=superseded
deprecated.reason.UNIMPLEMENTED=unimplemented

experimental.description=description: %s
experimental.stage=stage: %s
experimental.stage.DANGEROUS=dangerous
experimental.stage.UNSTABLE=unstable
experimental.stage.UNRECOMMENDED=unrecommended
experimental.stage.BETA=beta
experimental.stage.ALPHA=alpha
experimental.stage.PRERELEASE=pre-release

# Expressions

value.type=value type: %s
expression.type=expression type: %s
receiver.type=receiver type: %s

operator.declaration=operator declaration: %s
operator.unresolved='%s' could not be resolved to an operator
operator.invalid_position=the %2$s operator '%s' should not be used in %3$s position
operator.infix_none=the infix operator '%s' without associativity cannot be used in this position

this.assign=cannot assign a value to 'this'
this.access.unresolved=cannot resolve contextual type of 'this' expression
this.access.static='this' cannot be accessed in a static context
this.instance=no enclosing instance for '%s' available

super.assign=cannot assign a value to 'super'
super.access.static='super' cannot be accessed in a static context
super.access.type='super' cannot be accessed: the enclosing type does not have a super type
super.type.invalid=the requested super type is not a super type of the enclosing type
super.type.enclosing=the requested super type cannot be the enclosing type
super.type.indirect=the requested super type is not a direct super type of the enclosing type
super.type.interface.info=this access can be made valid by adding '%1$s' as a super-interface for '%2$s'
super.type.requested=requested super type: %s

# Casts

cast.type.invalid=invalid cast - missing target type
cast.value.invalid=invalid cast - missing left-hand expression
cast.unnecessary=unnecessary cast - the expression already has the target type '%1$s'
cast.incompatible=invalid cast - the expression of type '%1$s' cannot be casted to '%2$s' because the types are not \
  related (neither is a sub- or super-type of the other)
cast.optional.primitive=invalid cast - the expression of type '%1$s' cannot be optional-casted to '%2$s', optional casts \
  cannot involve primitive types

# Instance Checks

instanceof.type.invalid=invalid instance check - missing query type
instanceof.value.invalid=invalid instance check - missing left-hand expression
instanceof.value.primitive=invalid instance check - the expression must not have a primitive type
instanceof.type.primitive=invalid instance check - the query type must not be a primitive type
instanceof.type.equal=unnecessary instance check - the expression of type '%1$s' is always of type '%1$s' because they \
  are the same types
instanceof.type.subtype=unnecessary instance check - the expression of type '%1$s' is always of type '%2$s' because \
  '%1$s' is a sub-type of '%2$s'
instanceof.type.incompatible=invalid instance check - the expression of type '%1$s' can never be of type '%2$s' because \
  '%1$s' and '%2$s' are not related (neither is a sub- or super-type of the other)

# Array Literals

array.void=cannot create an array with element type 'void'
array.element.type.expected=expected element type: %s
array.element.type.actual=actual element type: %s
array.element.type.incompatible=the array element type is incompatible with the array type

map.key.side_effects=map expression keys should not have side effects
map.key.duplicate=duplicate map key '%s'
map.key.type.expected=expected key type: %s
map.key.type.actual=actual key type: %s
map.key.type.incompatible=the key type is incompatible with the required key type
map.value.type.expected=expected key type: %s
map.value.type.actual=actual key type: %s
map.value.type.incompatible=the value type is incompatible with the required value type

tuple.element.type.expected=expected tuple element type: %s
tuple.element.type.actual=actual tuple element type: %s
tuple.element.type.incompatible=the tuple type is incompatible with the required tuple type

lambda.parameter.type=the type of the lambda parameter '%s' could not be inferred
lambda.parameter.implicit=the type of the implicit lambda parameter could not be inferred
lambda.method=the lambda expression could not be linked to a functional method
lambda.value.type.incompatible=the lambda return value is incompatible with it's return type
lambda.value.invalid=invalid lambda expression - missing return value
lambda.return_type.incompatible=the explicit lambda return type is incompatible with the actual return type
lambda.return_type.infer=the return type of the lambda expression could not be inferred
lambda.return_type=lambda return type: %s

wildcard.type=wildcard target type: %s
wildcard.type.unresolved=the wildcard literal cannot be used where no type is expected
wildcard.type.no_default=the wildcard literal cannot be used in place of a type without a default value

string.interpolation.void=the string interpolation argument cannot be of type void
string.concat.void=expressions of type void cannot be part of string concatenation chains

colon_operator.left.type=the left value of the colon operator is incompatible with the expected type
colon_operator.left.invalid=invalid colon operator - missing left value
colon_operator.right.type=the right value of the colon operator is incompatible with the expected type
colon_operator.right.invalid=invalid colon operator - missing right value

classoperator.invalid=invalid class operator - type expected
typeoperator.invalid=invalid type operator - type expected
nullcheck.primitive=cannot perform a null pointer check on a primitive value
varargs.invalid=the varargs expansion operator can only be used in place of varargs parameters

range.type=range type: %s
range.start.type=the type of the range start is incompatible with the required type
range.end.type=the type of the range end is incompatible with the required type
range.element.type.incompatible=the element type of the range operator cannot be used for ranges, only numeric types \
  and subtypes of dyvil.collection.range.rangeable are allowed
range.element.type=range element type: %s

optional.unwrap.type.invalid=the type of the optional unwrap receiver is incompatible with the expected type
optional.chain.invalid=invalid optional chain operator - optional chain operators can only be used as the receiver of \
  an access expression
optional.chain.type.incompatible=the type of the optional chain receiver is incompatible with the expected type

# Patterns

case.invalid=invalid case statement - invalid expression
match.condition.type=the condition of a case condition has to evaluate to a boolean value
match.value.type.incompatible=the type of the match case is incompatible with the return type of the match expression
match.case.duplicate=duplicate match case with value '%s'

pattern.type=pattern type: %s
pattern.type.incompatible=the type of the pattern is incompatible with the matched value type
pattern.dead=unreachable pattern
pattern.object=the class '%s' cannot be used as an object class pattern
pattern.unapply.count=the case class pattern for '%s' has an invalid number of patterns
pattern.unapply.count.class=class parameter count: %s
pattern.unapply.count.pattern=pattern count: %s
pattern.unapply.type=the pattern is incompatible with the parameter type
pattern.tuple.element.type=the tuple pattern type is incompatible with the required tuple type
pattern.typecheck.invalid=invalid type check pattern - type expected

# Statements

if.condition.type=the condition of an if statement has to evaluate to a boolean value
if.condition.missing=invalid if statement - missing condition
if.then.type=the type of the then branch is incompatible with the required type
if.then.missing=invalid if statement - missing then branch
if.else.type=the type of the else branch is incompatible with the required type
if.binding.nonnull=the binding if statement cannot be used with a value of a non-nullable type

while.action.type=the action of a while statement has to be usable as a statement
while.condition.type=the condition of while statement has to evaluate to a boolean value
while.condition.invalid=invalid while statement - missing condition

repeat.action.type=the action of a repeat statement has to be usable as a statement
repeat.condition.type=the condition of a repeat statement has to evaluate to a boolean value

# For Statements

for.action.type=the action of a for statement has to be usable as a statement

for.each.type=the iterated value of the for each statement is incompatible with the required type
for.each.invalid=invalid for each statement - the expression cannot be iterated
for.variable.infer=the type of the loop variable '%s' could not be inferred
for.iterable.type=the element type of the iterable is incompatible with the variable type
for.iterator.type=the element type of the iterator is incompatible with the variable type
for.array.type=the element type of the iterated array is incompatible with the variable type
for.string.type=the type of the variable has to be 'char' when iterating over a string
for.range.type=the type of the iterated range is incompatible with the variable type

iterable.type=iterable type: %s
iterator.type=iterator type: %s

# Try / Catch Blocks

try.action.type.incompatible=the return type of the try block is incompatible with the required type
try.catch.type.not_throwable=the type of the catch block variable must be a subtype of java.lang.Throwable
try.catch.type.incompatible=the return type of the catch block is incompatible with the required type
try.catch.type=catch block type: %s
try.finally.type=the finally block of a try statement has to be usable as a statement

# Control Flow Statements

break.invalid=invalid break statement: break cannot be used in this context
break.invalid.target=invalid break statement: the statement labeled '%s' is not a loop
continue.invalid=invalid continue statement: continue cannot be used in this context
continue.invalid.target=invalid continue statement: the statement labeled '%s' is not a loop
goto.invalid=invalid goto statement: goto cannot be used in this context
goto.warning=goto should not be used

return.void.invalid=cannot return from a method with a return type other than 'void'
return.type.incompatible=the expression cannot be returned because it is incompatible with the return type of this context
return.type=return type: %s

# Misc.

value.constant=the expression could not be converted to a compile-time constant
value.constant.depth=max. constant folding depth: %d

literal.method=the literal conversion from %1$s to %2$s cannot be performed as the latter does not have a static %3$s method
literal.type.incompatible=the type of the literal conversion is incompatible with the required type
literal.type.conversion=conversion type: %s
literal.type.method=conversion method:\n\t\t%s

braceaccess.invalid=invalid brace access - no implicit value in scope

throw.type=the value of the throw statement must be a subtype of java.lang.Throwable
statementlist.statement=a statement in a statement list has to be usable as such
statementlist.return=the return value of the statement list has to be usable as a statement
statementlist.declaration.invalid=the %s cannot be declared in this context

# Exceptions

exception.unhandled=unhandled exception type '%s'
exception.type=exception type: %s
