package dyvilx.tools.parsing.marker

import dyvil.source.Source
import dyvil.source.position.SourcePosition
import dyvil.util.MarkerLevel

import java.io.Writer
import java.util.BitSet

case class MarkerPrinter(let source: Source, let style: MarkerStyle, let colors: boolean) {
	// =============== Methods ===============

	func print(markers: MarkerList, into writer: Writer) -> void {
		this.style match {
			case .DYVIL => this.printHuman(markers, writer)
			case .MACHINE => this.printMachine(markers, writer)
		}
	}

	// --------------- Dyvil Format ---------------

	package private func printHuman(markers: MarkerList, writer: Writer) -> void {
		markers.sort()
		let lines = new BitSet(this.source.lineCount)
		var lastLine = 0

		var i = markers.size - 1
		while i >= 0 {
			let marker = markers[i]
			let position = marker.position
			let endLine = position.endLine

			lines.set(position.startLine, endLine + 1)

			if endLine > lastLine {
				lastLine = endLine
			}

			i -= 1
		}

		let nBits = Math.log10(lastLine) as int + 1
		let formatString = "%\(nBits)d | %s\n"
		let indent = ("." * nBits) ++ " | "

		var markerIndex = 0
		var line = lines.nextSetBit(0)
		while line >= 0 {
			writer.write(String.format(formatString, line, this.source.line(line)))

			while markerIndex < markers.size && line == markers[markerIndex].position.endLine {
				this.printHuman(markers[markerIndex], indent, writer)
				markerIndex += 1
			}

			line = lines.nextSetBit(line + 1)
		}
	}

	package private func printHuman(marker: Marker, indent: String, writer: Writer) -> void {
		let position = marker.position
		let startColumn = position.startColumn
		let endColumn = position.endColumn

		let line = this.source.line(position.endLine)
		let limit = Math.min(startColumn, line.length)

		// does not append the actual line, only the indicator


		// --- Indicator ---
		writer.write(indent)

		for i <- 0 ..< limit {
			writer.write((line[i] == '\t') ? '\t' : ' ')
		}

		if this.colors {
			writer.write(marker.level.color)
		}

		for i <- startColumn ..< endColumn {
			writer.write('^')
		}
		if startColumn == endColumn {
			writer.write('^')
		}

		if this.colors {
			writer.write(Console.ANSI_RESET)
		}

		writer.write('\n')

		// --- Marker Level and Message ---
		writer.write(indent)

		if this.colors {
			writer.write(marker.level.color)
		}

		writer.write(levelName(marker.level))
		writer.write(": ")
		writer.write(marker.message)

		if this.colors {
			writer.write(Console.ANSI_RESET)
		}

		writer.write('\n')

		// --- Info ---
		for infoLine <- marker.info {
			writer.write(indent)
			writer.write('\t')
			writer.write(infoLine)
			writer.write('\n')
		}

		// --- Spacing ---
		writer.write(indent)
		writer.write('\n')
	}

	// --------------- Machine Format ---------------

	private func printMachine(markers: MarkerList, writer: Writer) -> void {
		markers.sort()
		for marker <- markers {
			this.printMachine(marker, writer)
		}
	}

	private func printMachine(marker: Marker, writer: Writer) -> void {
		let location = "\(sourcePath(this.source)):\(marker.position.toPositionString()): "

		writer.write(location)

		if this.colors {
			writer.write(marker.level.color)
		}

		writer.write(levelName(marker.level))
		writer.write(": ")
		writer.write(marker.message)

		if this.colors {
			writer.write(Console.ANSI_RESET)
		}

		writer.write('\n')

		for info <- marker.info {
			writer.write(location)
			writer.write(levelName("note"))
			writer.write(": ")
			writer.write(info)
			writer.write('\n')
		}
	}

	// --------------- Helper Methods ---------------

	private static func sourcePath(source: Source) -> String
		= source.filePath ?? BaseMarkers.INSTANCE.getString("marker.input_source")

	private static func levelName(level: MarkerLevel) -> String
		= levelName(level.name.toLowerCase())

	private static func levelName(levelID: String) -> String
		= BaseMarkers.INSTANCE.getString("marker_level.\(levelID)")
}
