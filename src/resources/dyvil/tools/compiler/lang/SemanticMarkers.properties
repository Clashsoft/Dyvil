# General

member.named=%1$s '%2$s'
member.class=class
member.field=field
member.method=method
member.constructor=constructor
member.initializer=initializer
member.classparameter=class parameter
member.variable=variable
member.typeargument=type argument
member.property=property
member.property.setter=property setter
member.property.getter=property getter

# Resolution

resolve.any='%s' could not be resolved to a type, method or field
resolve.package='%s' could not be resolved to a package or class
resolve.header='%s' could not be resolved to a header file
resolve.type='%s' could not be resolved to a type
resolve.type.package='%1$s' could not be resolved to a type in '%2$s'
resolve.method='%s' could not be resolved to a method
resolve.field='%s' could not be resolved to a field
resolve.method_field='%s' could not be resolved to a method or field
resolve.constructor=The constructor for '%s' could not be resolved
resolve.label='%s' could not be resolved to a label

# Headers

package.missing=Missing Package Declaration
package.invalid=Invalid Package Declaration in package '%s'
package.default=Invalid Package Declaration in default package

import.invalid=Invalid Import Declaration
import.wildcard.invalid=Wildcard Imports cannot be used on classes in Import Declarations, use a Using Declaration instead
using.invalid=Invalid Using Declaration
using.wildcard.invalid=Wildcard Imports cannot be used on packages in Using Declarations, use an Import Declaration instead
using.class.invalid=Using Declarations cannot point to classes, use an Import Declaration instead

include.unit=The Dyvil Unit '%s' cannot be included because it does not have a Header Declaration
include.internal=The internal header '%s' cannot be included because it is private to it's library
include.invisible=The header '%s' cannot be included because it is not visible

header.name.mismatch=Invalid Header Declaration - Mismatching Names
header.name=Header Name: %s
header.declaration.name=Header Declaration Name: %s

typealias.invalid=Invalid Type Alias - Type expected

# Types

typevariable=Type Variable: %s

type.class.generic=Generic Types cannot be used at this location
type.class.lambda=Lambda Types cannot be used at this location
type.class.typevar=Type Variable Types cannot be used at this location
type.super.array=Array Types cannot be used as super types
type.super.typevar=Type Variable Types cannot be used as super types
type.wildcard.invalid=Wildcard Types cannot be used at this location
type.lambda.return=Invalid Lambda Type - Missing Return Type
type.annotated.invalid=Invalid Annotated Type - Type expected
type.generic.class_not_generic=The non-generic class '%s' cannot be parameterized
type.dimensions=Type Dimensions: %d
type.expected=Expected Type: %s
type.enclosing=Enclosing Type: %s

type.access.invisible=The type '%s' cannot be accessed because it is not visible
type.access.internal=The internal class '%s' cannot be accessed because it is private to it's library
type.access.invalid=The instance of the type '%s' cannot be accessed because it is not an object type

# Annotations

annotation.type=The type '%s' is not an annotation type
annotation.target=The annotation type '%s' is not applicable for the target
annotation.target.element=Element Target Type: %s
annotation.target.allowed=Allowed Target Types: %s
annotation.method='%2$s' could not be resolved to an annotation interface method for '%1$s'
annotation.constant=The value for '%s' has to be a constant expression
annotation.parameter.missing=The annotation of type '%1$s' does not provide a value for the non-default parameter '%2$s'
annotation.parameter.type=The value for '%s' is incompatible with the required type
annotation.array.not_constant=The array element cannot be converted to a compile-time constant
annotation.field.not_constant=The field '%1$s' cannot be folded to a compile-time constant

# -- Classes --

class.extend.type=The %1$s '%2$s' cannot be extended, only classes are allowed
class.extend.final=The final class '%s' cannot be extended
class.extend.internal=The internal class '%s' cannot be extended
class.implement.type=The %1$s '%2$s' cannot be implemented, only interfaces are allowed
class.implement.internal=The internal interface '%s' cannot be extended
class.object.constructor=The object class '%s' cannot have a constructor
class.method.abstract=The type '%1$s' doesn't override the abstract method '%2$s' of the super type '%3$s'
class.method.conflict=Conflicting interface method '%1$s' in direct super-interfaces of class '%2$s', override this method

# Class Parameters

classparameter.type=Class Parameter Type: %s
classparameter.type.incompatible=The default value of the class parameter '%s' is incompatible with the parameter type
classparameter.type.infer=The type of the class parameter '%s' cannot be inferred
classparameter.type.void=Class Parameters cannot have the type void

classparameter.access.instance=The class parameter '%s' cannot be accessed from a static context
classparameter.access.unqualified=The class parameter '%s' should be qualified with 'this'
classparameter.assign.final=The final class parameter '%s' cannot be assigned
classparameter.assign.type=The type of the assigned value is incompatible with the type of the class parameter '%s'
classparameter.assign.annotation=The annotation parameter '%s' cannot be assigned

# -- Members --

# Modifiers

modifiers.illegal=The %1$s has illegal modifiers: %2$s
modifiers.static.unimplemented=The %1$s is declared static, but does not have an implementation
modifiers.static.abstract=The %1$s cannot be declared both static and abstract
modifiers.native.implemented=The %1$s cannot be declared native if it has an implementation
modifiers.native.abstract=The %1$s cannot be declared both native and abstract
modifiers.abstract.implemented=The %1$s cannot be declared abstract if it has an implementation
modifiers.abstract.concrete_class=The %1$s cannot be declared abstract as a member of the concrete type %2$s
modifiers.unimplemented=The %1$s is not implemented, but does not have an abstract modifier

# Initializers

initializer.type=The block of an Initializer has to be usable as a statement

# Constructors

constructor.invalid=Invalid Constructor
constructor.abstract=The constructor does not have an implementation
constructor.interface=The interface '%s' cannot be instantiated
constructor.type=The constructor must not return a result
constructor.static=Constructors cannot be declared static
constructor.unimplemented=The constructor is not implemented, but does not have an abstract modifier
constructor.typevar.infer=The type argument for the type variable '%2$s' of the class '%1$s' was inferred to any
constructor.return=Constructors cannot return a value

constructor.access.abstract=The abstract class '%s' cannot be instantiated
constructor.access.invisible=The constructor for '%s' cannot be accessed because it is not visible
constructor.access.internal=The internal constructor for '%s' cannot be accessed because it is private to it's library
constructor.access.array=Invalid Array Constructor Argument List
constructor.access.array.length=Mismatching number of array length parameters and type dimensions
constructor.access.array.count=Number of Length Parameters: %d
constructor.access.array.type=The array length parameter has to be of type int
constructor.access.array.typevar=Cannot create an array of the non-reified generic type %s

# -- Methods --

method.type=Method Return Type: %s
method.type.incompatible=The expression type of the method '%s' is incompatible with the return type
method.type.infer=The type of the method '%s' cannot be inferred
method.type.abstract=The type of the abstract method '%s' cannot be inferred
method.exception.type=The thrown exception must be a subtype of java.lang.Throwable
method.receivertype.incompatible=The receiver type of the method '%s' is incompatible with the enclosing class

method.receivertype=Receiver Type: %s
method.classtype=Class Type: %s

method.override.notfound=The method '%s' must override or implement a supertype method
method.overrides=The method '%s' overrides a method, but does not have an 'override' modifier
method.override.final=The method '%s' cannot override a final method
method.override=Overriden Method: %s from class %s
method.override.type=Overriden Return Type: %s
method.override.type.incompatible=The return type of the method '%s' is incompatible with the overridden method type

method.duplicate=Duplicate method '%1$s' with erased signature '%2$s'
method.typevar.infer=The type argument for the type variable '%2$s' of the method '%1$s' was inferred to any

method.access.invisible=The method '%s' cannot be accessed because it is not visible
method.access.internal=The internal method '%s' cannot be accessed because it is private to it's library
method.access.static=The static method '%s' should be accessed in a static way
method.access.static.type=The static method '%1$s' of type '%2$s' should be accessed from that type
method.access.instance=The instance method '%s' cannot be accessed from a static context
method.access.unqualified=The instance method '%s' should be qualified with 'this'
method.access.infix_type=The infix method argument for '%s' is incompatible with the required type
method.access.receiver_type=The receiver for the instance method '%s' incompatible with the required receiver type
method.access.prefix_type=The prefix method argument for '%s' is incompatible with the required type
method.access.argument_type=The method argument for '%s' is incompatible with the required type

# Parameters

parameter.type=Parameter Type: %s
parameter.type.incompatible=The default value of the parameter '%s' is incompatible with the parameter type
parameter.type.infer=The type of the parameter '%s' cannot be inferred
parameter.type.void=Parameters cannot have the type void

parameter.assign.final=The final parameter '%s' cannot be assigned
parameter.assign.type=The type of the assigned value is incompatible with the type of the parameter '%s'

arguments.duplicate.key=Duplicate Named Parameter '%s'

# Generics

generic.upperbound=Only one generic upper bound of '%s' can be a class
generic.not_generic='%s' is not a generic type
generic.count=Invalid number of generic type arguments
generic.type=Generic Type Argument: %s
generic.type.incompatible=The generic type argument is incompatible with the type variable '%s'

# Properties

property.initializer.type=The initializer of a Property has to be usable as a statement
property.initializer.interface=Property Initializers cannot be used in interfaces or traits

# Fields

field.type=Field Type: %s
field.type.incompatible=The initial value of the field '%s' is incompatible with the field type
field.type.infer=The type of the field '%s' cannot be inferred
field.type.infer.novalue=The type of the uninitialized field '%s' cannot be inferred
field.type.void=Fields cannot have the type void
field.illegal_modifiers=The field '%1$s' has illegal modifiers: %2$s
field.trait.warning=The field '%s' is implicitly public, static and final

field.access.invisible=The field '%s' cannot be accessed because it is not visible
field.access.internal=The internal field '%s' cannot be accessed because it is private to it's library
field.access.instance=The instance field '%s' cannot be accessed from a static context
field.access.static=The static field '%s' should be accessed in a static way
field.access.static.type=The static field '%1$s' of type '%2$s' should be accessed from that type
field.access.receiver_type=The receiver for the instance field '%s' incompatible with the required receiver type
field.access.unqualified=The instance field '%s' should be qualified with 'this'
field.assign.type=The type of the assigned value is incompatible with the type of the field '%s'
field.assign.final=The final field '%s' cannot be assigned

# Variables

variable.type=Variable Type: %s
variable.type.incompatible=The initial value of the variable '%s' is incompatible with the variable type
variable.type.infer=The type of the variable '%s' cannot be inferred
variable.type.void=Variables cannot have the type void
variable.assign.type=The type of the assigned value is incompatible with the type of the variable '%s'
variable.assign.final=The final variable '%s' cannot be assigned

variable.access.capture=The parameter '%s' cannot be accessed in this context because it is neither final nor \
  effectively final and cannot be converted to a Reference Variable
variable.assign.capture=The parameter '%s' cannot be assigned as it cannot be converted to a Reference Variable

# References

reference.expression.invalid=The expression cannot be referenced
reference.parameter.capture=The parameter '%s' cannot be converted to a reference
reference.field.final=The final field '%s' cannot be converted to a reference

# Deprecation

deprecated.since=Deprecated Since: %s
deprecated.reason=Reason: %s
deprecated.reasons=Reasons: %s
deprecated.description=Description: %s

experimental.stage=Stage: %s
experimental.description=Description: %s

# Expressions

value.type=Value Type: %s
action.type=Action Type: %s
receiver.type=Receiver Type: %s

this.assign=Cannot assign a value to 'this'
this.access.static='this' cannot be accessed in a static context
this.instance=No enclosing instance for '%s' available

super.assign=Cannot assign a value to 'super'
super.access.static='super' cannot be accessed in a static context
super.access.type='super' cannot be accessed: The enclosing type does not have a super type
super.type.invalid=The requested super type is not a super type of the enclosing type
super.type.indirect=The requested super type is not a direct super type of the enclosing type
super.type.requested=Requested Super Type: %s

cast.type.invalid=Invalid Cast - Type expected
cast.value.invalid=Invalid Cast - Expression expected
cast.unnecessary=Unnecessary Cast: The value is already of the casted type
cast.void=Invalid Cast: Cannot cast to void
cast.incompatible=Invalid Cast: The expression of type %1$s cannot be casted to %2$s because %1$s is neither a super-type nor a sub-type of %2$s

instanceof.type.invalid=Invalid Instance Check - Type expected
instanceof.value.invalid=Invalid Instance Check - Expression expected
instanceof.value.primitive=Instance checks cannot be performed on primitive expressions
instanceof.type.primitive=Instance checks cannot be performed with primitive types
instanceof.type.equal=Unnecessary instance check: The expression is already of type %1$s
instanceof.type.subtype=Unnecessary instance check: The expression of type %1$s can only be of type %2$s because %1$s is a sub-type of %2$s
instanceof.type.incompatible=Invalid instance check: The expression of type %1$s can never be of type %2$s because %1$s is neither a super-type nor a sub-type of %2$s

array.type=Array Type: %s
array.element.type=Element Type: %s
array.element.type.incompatible=The array element type is incompatible with the array type

map.key.type=Key Type: %s
map.key.type.incompatible=The key type is incompatible with the required key type
map.value.type=Value Type: %s
map.value.type.incompatible=The value type is incompatible with the required value type

tuple.element.type=Tuple Element Type: %s
tuple.element.type.incompatible=The tuple type is incompatible with the required tuple type
tuple.method=The literal conversion from (%1$s) to %2$s cannot be performed as %2$s does not have a static apply(%1$s) method

lambda.parameter.type=The type of the Lambda Parameter '%s' cannot be inferred
lambda.method=The Lambda Expression could not be linked to a functional method
lambda.type=The return value of the Lambda Expression is incompatible with the linked method's return type

nil.type=The Nil Literal cannot be used in this context because the expected type '%1$s' does not have an \
  'NilConvertible' annotation.
nil.untyped=The Nil Literal cannot be used in a context where no type is expected
nil.method=The Nil Conversion to %1$s cannot be performed because '%1$s' does not have a static %2$s() method

wildcard.type=The Wildcard Literal cannot be used where no type is expected

string.interpolation.void=The String Interpolation argument cannot be of type void
string.concat.void=Expressions of type void cannot be part of String Concatenation Chains

classoperator.invalid=Invalid Class Operator - Type expected
typeoperator.invalid=Invalid Type Operator - Type expected
typeoperator.typevar=Type Operators cannot contain references to Type Variables
nullcheck.primitive=Cannot perform a Null Pointer Check on a primitive value
range.type=Range Type: %s
range.start.type=The type of the range start is incompatible with the required type
range.end.type=The type of the range end is incompatible with the required type

# Patterns

case.invalid=Invalid Case Statement - Invalid Expression
match.invalid=Invalid Match Expression - Expression expected
match.condition.type=The condition of a Case Condition has to evaluate to a boolean value
match.value.type.incompatible=The type of the match case is incompatible with the return type of the match expression

pattern.type=Pattern Type: %s
pattern.type.incompatible=The type of the pattern is incompatible with the matched value type
pattern.dead=Unreachable Pattern
pattern.object=The class '%s' cannot be used as an Object Class Pattern
pattern.class.count=The Case Class Pattern for '%s' has an invalid number of patterns
pattern.class.count.class=Class Parameter Count: %s
pattern.class.count.pattern=Pattern Count: %s
pattern.class.access=The parameter '%s' cannot be extracted because it is not visible and no getter method is available
pattern.class.access.type=Case Class Type: %s
pattern.class.type=The pattern for the parameter '%1$s' is incompatible with the parameter type
pattern.tuple.element.type=The tuple pattern type is incompatible with the required tuple type
pattern.typecheck.invalid=Invalid Type Check pattern - Type expected

# Statements

if.condition.type=The Condition of an If Statement has to evaluate to a boolean value
if.condition.invalid=Invalid If Statement - Missing Condition
if.then.type=The type of the then branch is incompatible with the required type
if.else.type=The type of the else branch is incompatible with the required type

while.action.type=The action of a While Statement has to be usable as a statement
while.condition.type=The condition of While Statement has to evaluate to a boolean value
while.condition.invalid=Invalid While Statement - Missing Condition

do.action.type=The action of a Do Statement has to be usable as a statement
do.condition.type=The condition of a Do-While Statement has to evaluate to a boolean value
do.condition.invalid=Invalid Do-While Statement - Missing Condition

# For Statements

for.condition.type=The condition of a For Statement has to evaluate to a boolean value
for.update.type=The update of a For Statement has to be usable as a statement
for.action.type=The action of a For Statement has to be usable as a statement

for.each.invalid=Invalid For Each Statement - The expression cannot be iterated
for.variable.infer=The type of the loop variable '%s' cannot be inferred
for.iterable.type=The type of the Iterable is incompatible with the variable type
for.array.type=The type of the iterated array is incompatible with the variable type
for.string.type=The type of the variable has to be 'char' when iterating over a String
for.range.type=The type of the iterated range is incompatible with the variable type

iterable.type=Iterable Type: %s

# Try / Catch Blocks

try.action.type.incompatible=The return type of the Try Block is incompatible with the required type
try.catch.type.not_throwable=The type of the Catch Block Variable must be a subtype of java.lang.Throwable
try.catch.type.incompatible=The return type of the Catch Block is incompatible with the required type
try.finally.type.invalid=The Finally Block of a Try Statement has to be usable as a statement

try.finally.type=Finally Block Type: %s
try.catchblock.type=Catch Block Type: %s

break.invalid=Invalid break Statement: break cannot be applied in the current context
break.invalid.type=Invalid break Statement: The statement labeled '%s' is not a loop
continue.invalid=Invalid continue Statement: continue cannot be applied in the current context
continue.invalid.type=Invalid continue Statement: The statement labeled '%s' is not a loop
goto.invalid=Invalid goto Statement: goto cannot be applied in the current context
goto.warning=goto should not be used

value.constant=The expression could not be converted to a compile-time constant
literal.method=The literal conversion from %1$s to %2$s cannot be performed as %2$s does not have a static apply%3$s method
literal.type.incompatible=The type of the literal conversion is incompatible with the required type
literal.type.conversion=Conversion Type: %s
literal.type.method=Conversion Method:

throw.type=The value of the throw statement must be a subtype of java.lang.Throwable
statementlist.statement=A statement in a statement list has to be usable as such

return.void.invalid=Cannot return from a method with a return type
return.type.incompatible=The expression cannot be returned in this context because of an incompatible return type
return.type=Return Type: %s

# Exceptions

exception.unhandled=Unhandled Exception type '%s'
exception.type=Exception Type: %s
