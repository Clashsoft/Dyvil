// GEN_NOTICE
// Timestamp: TIME_STAMP

#if (IS_HALF_OPEN) {
	package dyvil.collection.range.halfopen

	#define (LESS_OP) {<}
	#define (RANGE_OP) {..<}
}
#else {
	package dyvil.collection.range.closed

	#define (LESS_OP) {<=}
	#define (RANGE_OP) {..}
}

import dyvil.collection.range.Rangeable
import java.util.Iterator
import java.util.NoSuchElementException
import java.util.function.Consumer
import java.io.IOException

@LiteralConvertible.FromTuple
@Immutable
case class ObjectRange<type +T: Rangeable<T>>(
	protected @transient let start: T
	protected @transient let end: T
) implements Range<T>
{
	#if (IS_HALF_OPEN) {
		override func isHalfOpen() -> boolean = true

		override func asHalfOpen() -> Range<T> = this

		override func asClosed() -> Range<T> = new dyvil.collection.range.closed.ObjectRange<T>(this.start, this.end)
	}
	#else {
		override func isHalfOpen() -> boolean = false

		override func asHalfOpen() -> Range<T> = new dyvil.collection.range.halfopen.ObjectRange<T>(this.start, this.end)

		override func asClosed() -> Range<T> = this
	}

	override func first() -> T = this.start

	#if (IS_HALF_OPEN) {
		override func last() -> T = this.end.prev

		override func size() -> int = this.start.distanceTo(this.end)
	}
	#else {
		override func last() -> T = this.end

		override func size() -> int = this.start.distanceTo(this.end) + 1
	}

	override func iterator() -> Iterator<T> = new Iterator<T>()
	{
		var current: T = this<ObjectRange>.start

		override func next() -> T
		{
			if (!this.hasNext()) throw new NoSuchElementException("End of Range")

			let c = this.current
			this.current = this.current.next
			return c
		}

		override func hasNext() -> boolean
		{
			return this.current LESS_OP this<ObjectRange>.end
		}

		override func toString() -> String = "RangeIterator(\(this<ObjectRange>), current: \(this.current))"
	}

	#define(FOR_EACH) {for (var current = this.start; current LESS_OP this.end; current = current.next)}

	override func forEach(action: T -> void) -> void = FOR_EACH action(current)

	override func contains(element: any!)
	{
		FOR_EACH if (current == element) return true
		return false
	}

	override func copy() -> ObjectRange<T> = new ObjectRange<T>(this.start, this.end)

	override func copy(to: [Object!], index: int) -> void = FOR_EACH to[index++] = current

	override func toString() -> String = this.start + " RANGE_OP " + this.end

	override func equals(obj: any!) -> boolean = Range.rangeEquals(this, obj)

	override func hashCode() -> int = Range.rangeHashCode(this)
}
