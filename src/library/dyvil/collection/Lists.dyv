package dyvil.collection

import java.util.{ Collection, List, ArrayList, LinkedList, concurrent.CopyOnWriteArrayList }
import java.util.function.{ IntFunction, Supplier }
import java.util.Comparator
import java.util.Random

import java.util.{ Arrays, Collections }
import dyvil.ref.ObjectRef

// *************** List ***************

@JavaName("Lists")
extension<type E> List<E> {
	// =============== Static Methods ===============

	// List<Int>()
	@JavaName("empty")
	static func apply<type E>() -> @Immutable List<E> = Collections.emptyList<E>()

	// List(1)
	@JavaName("of")
	static func apply<type E>(element: E) -> @Immutable List<E> = Collections.singletonList(element)

	// List(1, 2, 3)
	@JavaName("of")
	static func apply<type E>(elements: E...) -> @Immutable List<E> = Arrays.asList(elements...).unmodifiableView

	// List(withContentsOf: someCollection)
	@JavaName("copyOf")
	static func apply<type E>(withContentsOf c: Collection<+E>) -> @Immutable List<E>
		= new ArrayList(c).unmodifiableView

	// List<String>() { add("a"); add("b") }
	@JavaName("build")
	static func apply<type E>(builtBy configure: List<E>.() -> void) -> @Immutable List<E> {
		let list = new ArrayList<E>()
		configure(list)
		return list.unmodifiableView
	}

	// List(with: 10, copiesOf: "a")
	@JavaName("repeat")
	static func apply<type E>(with n: int, explicit copiesOf element: E) -> @Immutable List<E>
		= Collections.nCopies(n, element)

	// List(with: 10, itemsGeneratedBy: i => i + 1)
	@JavaName("generate")
	static func apply<type E>(with n: int, explicit itemsGeneratedBy generator: IntFunction<+E>) -> @Immutable List<E> {
		let list = new ArrayList<E>(n)
		for i <- 0 ..< n {
			list.add(generator(i))
		}
		return list
	}

	// List(with: 10, itemsGeneratedBy: => random.nextInt())
	@JavaName("generate")
	static func apply<type E>(with n: int, explicit itemsGeneratedBy supplier: Supplier<+E>) -> @Immutable List<E> {
		let list = new ArrayList<E>(n)
		for i <- 0 ..< n {
			list.add(supplier.get())
		}
		return list.unmodifiableView
	}

	// =============== Methods ===============

	// --------------- Search ---------------

	@JavaName("indexOfSubList")
	final func indexOf(subList: List<_>) -> int = Collections.indexOfSubList(this, subList)

	@JavaName("lastIndexOfSubList")
	final func lastIndexOf(subList: List<_>) -> int = Collections.lastIndexOfSubList(this, subList)

	// func binarySearch(this: List<+Comparable<-E>>, key: E) -> int = Collections.binarySearch(this, key)

	final func binarySearch(key: E, comparator: Comparator<-E>) -> int = Collections.binarySearch(this, key, comparator)

	// --------------- Indexed Subscript ---------------

	final func subscript(index: int) -> E = this.get(index)

	@Mutating
	final func subscript_=(index: int, element: E) -> void = this.set(index, element)

	@Mutating
	final func subscript_&(index: int) -> E* = new ListRef<E>(this, index)

	// TODO use an anonymous class when #462 is fixed
	private static class ListRef<type E>(let list: List<E>, let index: int) implements ObjectRef<E> {
		override func get() -> E = this.list.get(index)

		override func set(value: E) -> void = this.list.set(index, value)
	}

	// --------------- Range Subscript ---------------

	final func subscript(range: Range<Int>) -> List<E> = this.subList(range.first, range.size)

	@Mutating
	final func subscript_=(range: Range<Int>, values: List<+E>) -> void {
		if values.size != range.size {
			throw new IllegalArgumentException("range size and list size must be equal")
		}

		Collections.copy(this[range], values)
	}

	@Mutating
	final func subscript_=(range: Range<Int>, values: [E]) -> void = this[range] = Arrays.asList(values...)

	// --------------- Mutation ---------------

	@Mutating
	final func replaceAll(occurrencesOf oldVal: any!, with newVal: E) -> void
		= Collections.replaceAll(this, oldVal, newVal)

	@Mutating
	final func swap(i: int, j: int) -> void = Collections.swap(this, i, j)

	// --------------- Order ---------------

	@Mutating
	final func reverse() -> void = Collections.reverse(this)

	@Mutating
	final func rotate(distance: int) -> void = Collections.rotate(this, distance)

	@Mutating
	final func shuffle() -> void = Collections.shuffle(this)

	@Mutating
	final func shuffle(random: Random) -> void = Collections.shuffle(this, random)

	@Mutating
	final func sort() -> void = this.sort(null)

	// --------------- Views ---------------

	final func unmodifiableView() -> List<E> = Collections.unmodifiableList(this)

	final func synchronizedView() -> List<E> = Collections.synchronizedList(this)

	// func checked(withType: Class<-E>) -> List<E> = Collections.checkedList(this, withType)
}

// *************** ArrayList ***************

@JavaName("ArrayLists")
extension ArrayList {
	// =============== Static Methods ===============

	// ArrayList<Int>()
	@JavaName("empty")
	static func apply<type E>() -> ArrayList<E> = new ArrayList<E>()

	// ArrayList(1)
	@JavaName("of")
	static func apply<type E>(element e: E) -> ArrayList<E> = new ArrayList<E>().{ $0.add(e); $0 }

	// ArrayList(1, 2, 3)
	@JavaName("of")
	static func apply<type E>(elements: E...) -> ArrayList<E> = new ArrayList<E>(Arrays.asList(elements...))

	// ArrayList<Int>(withContentsOf: someCollection)
	@JavaName("copyOf")
	static func apply<type E>(explicit withContentsOf collection: Collection<+E>) -> ArrayList<E>
		= new ArrayList<E>(collection)

	// ArrayList<Int>(capacity: 5)
	@JavaName("withCapacity")
	static func apply<type E>(explicit capacity: int) -> ArrayList<E> = new ArrayList<E>(capacity)
}

// *************** LinkedList ***************

@JavaName("LinkedLists")
extension LinkedList {
	// =============== Static Methods ===============

	// LinkedList<Int>()
	@JavaName("empty")
	static func apply<type E>() -> LinkedList<E> = new LinkedList<E>()

	// LinkedList(1)
	@JavaName("of")
	static func apply<type E>(element e: E) -> LinkedList<E> = new LinkedList<E>().{ $0.add(e); $0 }

	// LinkedList(1, 2, 3)
	@JavaName("of")
	static func apply<type E>(elements: E...) -> LinkedList<E> = new LinkedList<E>(Arrays.asList(elements...))

	// LinkedList(withContentsOf: someCollection)
	@JavaName("copyOf")
	static func apply<type E>(explicit withContentsOf collection: Collection<+E>) -> LinkedList<E>
		= new LinkedList<E>(collection)
}

/*

// *************** CopyOnWriteArrayList ***************

@JavaName("CopyOnWriteArrayLists")
extension CopyOnWriteArrayList {
	// =============== Static Methods ===============

	static func apply<type E>() -> CopyOnWriteArrayList<E>
		= new CopyOnWriteArrayList<E>()

	static func apply<type E>(element: E) -> CopyOnWriteArrayList<E>
		= new CopyOnWriteArrayList<E>(Collections.singletonList(element))

	static func apply<type E>(elements: E...) -> CopyOnWriteArrayList<E>
		= new CopyOnWriteArrayList<E>(Arrays.asList(elements...))

	static func apply<type E>(withContentsOf collection: Collection<+E>) -> CopyOnWriteArrayList<E>
		= new CopyOnWriteArrayList<E>(collection)
}
*/
