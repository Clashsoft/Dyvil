package dyvil.collection

import java.util.{ Collection, List, ArrayList, LinkedList, concurrent.CopyOnWriteArrayList }
import java.util.function.{ IntFunction, Supplier }
import java.util.Comparator
import java.util.Random

import java.util.{ Arrays, Collections }
import dyvil.ref.ObjectRef

// *************** List ***************

@JavaName("Lists")
extension<type E> List<E> {
	// =============== Static Methods ===============

	// List<Int>()
	@JavaName("empty")
	static func apply<type E>() -> @Immutable List<E> = Collections.emptyList<E>()

	// List(1)
	@JavaName("of")
	static func apply<type E>(element: E) -> @Immutable List<E> = Collections.singletonList(element)

	// List(1, 2, 3)
	@JavaName("of")
	static func apply<type E>(elements: E...) -> @Immutable List<E> = Arrays.asList(elements...).unmodifiableView

	// List(withContentsOf: someCollection)
	@JavaName("copyOf")
	static func apply<type E>(withContentsOf c: Collection<+E>) -> @Immutable List<E>
		= ArrayList(withContentsOf: c).unmodifiableView

	// List<String>() { add("a"); add("b") }
	@JavaName("build")
	static func apply<type E>(builtBy configure: List<E>.() -> void) -> @Immutable List<E> {
		let list = new ArrayList<E>()
		configure(list)
		return list.unmodifiableView
	}

	// List(with: 10, copiesOf: "a")
	@JavaName("repeat")
	static func apply<type E>(with n: int, explicit copiesOf element: E) -> @Immutable List<E>
		= Collections.nCopies(n, element)

	// List(with: 10, itemsGeneratedBy: i => i + 1)
	@JavaName("generate")
	static func apply<type E>(with n: int, explicit itemsGeneratedBy generator: IntFunction<+E>) -> @Immutable List<E> {
		let list = new ArrayList<E>(n)
		for i <- 0 ..< n {
			list.add(generator(i))
		}
		return list
	}

	// List(with: 10, itemsGeneratedBy: => random.nextInt())
	@JavaName("generate")
	static func apply<type E>(with n: int, explicit itemsGeneratedBy supplier: Supplier<+E>) -> @Immutable List<E> {
		let list = new ArrayList<E>(n)
		for i <- 0 ..< n {
			list.add(supplier.get())
		}
		return list
	}

	// =============== Methods ===============

	// --------------- Search ---------------

	@JavaName("indexOfSubList")
	func indexOf(subList: List<_>) -> int = Collections.indexOfSubList(this, subList)

	@JavaName("lastIndexOfSubList")
	func lastIndexOf(subList: List<_>) -> int = Collections.lastIndexOfSubList(this, subList)

	// func binarySearch(this: List<+Comparable<-E>>, key: E) -> int = Collections.binarySearch(this, key)

	func binarySearch(key: E, comparator: Comparator<-E>) -> int = Collections.binarySearch(this, key, comparator)

	// --------------- Indexed Subscript ---------------

	func subscript(index: int) -> E = this.get(index)

	@Mutating
	func subscript_=(index: int, element: E) -> void = this.set(index, element)

	@Mutating
	func subscript_&(index: int) -> E* = new ObjectRef<E>() {
		override func get() -> E = this<List<E>>.get(index)

		override func set(value: E) -> void = this<List<E>>.set(index, value)
	}

	// --------------- Range Subscript ---------------

	func subscript(range: Range<Int>) -> List<E> = this.subList(range.first, range.size)

	@Mutating
	func subscript_=(range: Range<Int>, values: List<+E>) -> void {
		if values.size != range.size {
			throw new IllegalArgumentException("range size and list size must be equal")
		}

		Collections.copy(this[range], values)
	}

	@Mutating
	func subscript_=(range: Range<Int>, values: [E]) -> void = this[range] = Arrays.asList(values...)

	// --------------- Mutation ---------------

	@Mutating
	func replaceAll(occurrencesOf oldVal: any!, with newVal: E) -> void = Collections.replaceAll(this, oldVal, newVal)

	@Mutating
	func swap(i: int, j: int) -> void = Collections.swap(this, i, j)

	// --------------- Order ---------------

	@Mutating
	func reverse() -> void = Collections.reverse(this)

	@Mutating
	func rotate(distance: int) -> void = Collections.rotate(this, distance)

	@Mutating
	func shuffle() -> void = Collections.shuffle(this)

	@Mutating
	func shuffle(random: Random) -> void = Collections.shuffle(this, random)

	@Mutating
	func sort() -> void = this.sort(null)

	// --------------- Views ---------------

	func unmodifiableView() -> List<E> = Collections.unmodifiableList(this)

	func synchronizedView() -> List<E> = Collections.synchronizedList(this)

	// func checked(withType: Class<-E>) -> List<E> = Collections.checkedList(this, withType)
}

// *************** ArrayList ***************

@JavaName("ArrayLists")
extension ArrayList {
	// =============== Static Methods ===============

	static func apply<type E>() -> ArrayList<E> = new ArrayList<E>()

	static func apply<type E>(element: E) -> ArrayList<E> = new ArrayList<E>().{ add(element); $0 }

	static func apply<type E>(elements: E...) -> ArrayList<E> = new ArrayList<E>(Arrays.asList(elements...))

	static func apply<type E>(withContentsOf collection: Collection<+E>) -> ArrayList<E> = new ArrayList<E>(collection)

	static func apply<type E>(withCapacity capacity: int) -> ArrayList<E> = new ArrayList<E>(capacity)
}

// *************** LinkedList ***************

@JavaName("LinkedLists")
extension LinkedList {
	// =============== Static Methods ===============

	static func apply<type E>() -> LinkedList<E> = new LinkedList<E>()

	static func apply<type E>(element: E) -> LinkedList<E> = new LinkedList<E>().{ add(element); $0 }

	static func apply<type E>(elements: E...) -> LinkedList<E> = new LinkedList<E>(Arrays.asList(elements...))

	static func apply<type E>(withContentsOf collection: Collection<+E>) -> LinkedList<E> = new LinkedList<E>(collection)
}

/*

// *************** CopyOnWriteArrayList ***************

@JavaName("CopyOnWriteArrayLists")
extension CopyOnWriteArrayList {
	// =============== Static Methods ===============

	static func apply<type E>() -> CopyOnWriteArrayList<E>
		= new CopyOnWriteArrayList<E>()

	static func apply<type E>(element: E) -> CopyOnWriteArrayList<E>
		= new CopyOnWriteArrayList<E>(Collections.singletonList(element))

	static func apply<type E>(elements: E...) -> CopyOnWriteArrayList<E>
		= new CopyOnWriteArrayList<E>(Arrays.asList(elements...))

	static func apply<type E>(withContentsOf collection: Collection<+E>) -> CopyOnWriteArrayList<E>
		= new CopyOnWriteArrayList<E>(collection)
}
*/
