package dyvil.collection

import java.util.Iterator
import dyvil.collection.iterator._

@JavaName("Iterators")
extension Iterator
{
	// =============== Constructors ===============

	@JavaName("empty")
	static func apply<type E>() -> Iterator<E> = EmptyIterator<E>()

	@JavaName("of")
	static func apply<type E>(element: E) -> Iterator<E> = SingletonIterator<E>(element)

	@JavaName("of")
	static func apply<type E>(elements: E...) -> Iterator<E> = ArrayIterator<E>(elements)

	// =============== Methods ===============

	// TODO convert mapped and filtered to proper extension funcs when generic extension classes are implemented

	infix func mapped<type E, type R>(_ base: Iterator<+E>, by mapper: E -> R) -> Iterator<R> = MappingIterator(base, mapper)

	infix func filtered<type E>(_ base: Iterator<+E>, by filter: E -> boolean) -> Iterator<E> = FilterIterator(base, filter)

	// =============== Operators ===============

	@JavaName("concat")
	infix func ++ <type E>(lhs: Iterator<+E>, rhs: Iterator<+E>) -> Iterator<E> = ConcatIterator(lhs, rhs)

	@JavaName("prepend")
	infix func + <type E>(lhs: E, rhs: Iterator<+E>) -> Iterator<E> = PrependIterator(lhs, rhs)

	@JavaName("append")
	infix func + <type E>(lhs: Iterator<+E>, rhs: E) -> Iterator<E> = AppendIterator(lhs, rhs)
}
