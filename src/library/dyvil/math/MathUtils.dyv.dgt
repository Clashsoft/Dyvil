// GEN_NOTICE
// Timestamp: TIME_STAMP

package dyvil.math

using java.lang.Math._

abstract class MathUtils
{
	private init() {} // no instances

	#define(SPECS){Base-Int.dgs, Base-Long.dgs, Base-Float.dgs, Base-Double.dgs}

	// min
	#for (spec <- SPECS) {
		#import(spec)

		static func min(this: Math, _ a: PRIMITIVE, _ b: PRIMITIVE, _ c: PRIMITIVE) -> PRIMITIVE = min(a, min(b, c))

		static func min(this: Math, _ values: PRIMITIVE...) -> PRIMITIVE
		{
			var min = #if (IS_FLOATING_POINT) {WRAPPER.POSITIVE_INFINITY} #else {WRAPPER.MAX_VALUE}

			for (v <- values) if (v < min) min = v
			return min
		}
	}

	// max
	#for (spec <- SPECS) {
		#import(spec)

		static func max(this: Math, _ a: PRIMITIVE, _ b: PRIMITIVE, _ c: PRIMITIVE) -> PRIMITIVE = max(a, max(b, c))

		static func max(this: Math, _ values: PRIMITIVE...) -> PRIMITIVE
		{
			var max = #if (IS_FLOATING_POINT) {WRAPPER.NEGATIVE_INFINITY} #else {WRAPPER.MIN_VALUE}

			for (v <- values) if (v > max) max = v
			return max
		}
	}

	// sum
	#for (spec <- SPECS) {
		#import(spec)

		static func sum(this: Math, _ values: PRIMITIVE...) -> PRIMITIVE
		{
			var sum: PRIMITIVE = 0
			for (v <- values) sum += v
			return sum
		}
	}

	static func sum(this: Math, k start: long, to end: long, _ f: long -> double) -> double
	{
		var sum = 0.0D
		for (k <- start .. end) sum += f(k)
		return sum
	}

	// product
	#for (spec <- SPECS) {
		#import(spec)

		static func product(this: Math, _ values: PRIMITIVE...) -> PRIMITIVE
		{
			var product: PRIMITIVE = 1
			for (v <- values) product *= v
			return product
		}
	}

	static func product(this: Math, k start: long, to end: long, _ f: long -> double) -> double
	{
		var product = 1.0D
		for (k <- start .. end) product *= f(k)
		return product
	}

	// average
	#for (spec <- SPECS) {
		#import(spec)

		static func average(this: Math, _ values: PRIMITIVE...) -> double = sum(values...) / (values.size as double)
	}

	// clamp
	#for (spec <- SPECS) {
		#import(spec)

		infix func clamp(this: Math, _ v: PRIMITIVE, min: PRIMITIVE, max: PRIMITIVE) -> PRIMITIVE
		{
			if (v < min) return min
			if (v > max) return max
			return v
		}
	}

	// interpolate
	#for (spec <- SPECS) {
		#import(spec)

		infix func interpolate(this: Math, _ v: double, min: PRIMITIVE, max: PRIMITIVE) -> PRIMITIVE
		{
			if (v <= 0) return min
			if (v >= 1) return max
			return (min + (max - min) * v) as PRIMITIVE
		}
	}

	// floor & ceil

	static func floor(_ f: float) -> int
	{
		let i = f as int
		return f < i ? i - 1 : i
	}

	static func floor(_ d: double) -> long
	{
		let l = d as long
		return d < l ? l - 1 : l
	}

	static func ceil(_ f: float) -> int
	{
		let i = f as int
		return f > i ? i + 1 : i
	}

	static func ceil(_ d: double) -> long
	{
		let l = d as long
		return d > l ? l + 1 : l
	}

	// factorial

	postfix func !(_ lhs: long) -> long
	{
		var l = lhs
		while (lhs > 1)
		{
			lhs -= 1
			l *= lhs
		}
		return l
	}

	static func nPr(this: Math, n: long, r: long) -> long = n! \ (n - r)!

	static func nCr(this: Math, n: long, r: long) -> long = n! \ (r! * (n - r)!)

	// powers of two

	prefix func nextPowerOf2(this: Math, _ v: int) -> int
	{
		var j = v - 1
		j |= j >> 1
		j |= j >> 2
		j |= j >> 4
		j |= j >> 8
		j |= j >> 16
		return j + 1
	}

	prefix func isPowerOf2(this: Math, _ v: int) -> boolean = (v & -v) == v

	private const deBruijnBits: [int] = [ 0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31,
		27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9 ]

	private static func deBruijn(v: int) -> int = deBruijnBits[(v * 125613361L >> 27) as int & 0x1F]

	static func log2(this: Math, _ v: int) -> int = isPowerOf2(v) ? deBruijn(v) : deBruijn(nextPowerOf2(v)) - 1
}
