// GEN_NOTICE
// Timestamp: TIME_STAMP

package dyvil.math

using java.lang.Math._

abstract class MathUtils
{
	private init() {} // no instances

#define SPECS Base-Int.dgs, Base-Long.dgs, Base-Float.dgs, Base-Double.dgs

	// min
#foreach SPECS

	static func min(this: Math, a: PRIMITIVE, b: PRIMITIVE, c: PRIMITIVE) -> PRIMITIVE = min(a, min(b, c))

	static func min(this: Math, values: PRIMITIVE...) -> PRIMITIVE
	{
	#if IS_FLOATING_POINT
		var min = WRAPPER.POSITIVE_INFINITY
	#else
		var min = WRAPPER.MAX_VALUE
	#end
		for (v <- values) if (v < min) { min = v }
		return min
	}
#end

	// max
#foreach SPECS

	static func max(this: Math, a: PRIMITIVE, b: PRIMITIVE, c: PRIMITIVE) -> PRIMITIVE = max(a, max(b, c))

	static func max(this: Math, values: PRIMITIVE...) -> PRIMITIVE
	{
	#if IS_FLOATING_POINT
		var max = WRAPPER.NEGATIVE_INFINITY
	#else
		var max = WRAPPER.MIN_VALUE
	#end
		for (v <- values) if (v > max) { max = v }
		return max
	}
#end

	// sum
#foreach SPECS

	static func sum(this: Math, values: PRIMITIVE...) -> PRIMITIVE
	{
		var sum: PRIMITIVE = 0
		for (v <- values) sum += v
		return sum
	}
#end

	// product
#foreach SPECS

	static func product(this: Math, values: PRIMITIVE...) -> PRIMITIVE
	{
		var product: PRIMITIVE = 1
		for (v <- values) product *= v
		return product
	}
#end

	// average
#foreach SPECS

	static func average(this: Math, values: PRIMITIVE...) -> double = sum(values...) / (values.size as double)
#end

	// clamp

#foreach SPECS

	infix func clamp(this: Math, v: PRIMITIVE, min: PRIMITIVE, max: PRIMITIVE) -> PRIMITIVE
	{
		if (v < min) return min
		if (v > max) return max
		return v
	}
#end

	// interpolate

#foreach SPECS

	infix func interpolate(this: Math, v: double, min: PRIMITIVE, max: PRIMITIVE) -> PRIMITIVE
	{
		if (v <= 0) return min
		if (v >= 1) return max
		return (min + (max - min) * v) as PRIMITIVE
	}
#end

	// floor & ceil

	static func floor(f: float) -> int
	{
		let i = f as int
		return f < i ? i - 1 : i
	}

	static func floor(d: double) -> long
	{
		let l = d as long
		return d < l ? l - 1 : l
	}

	static func ceil(f: float) -> int
	{
		let i = f as int
		return f > i ? i + 1 : i
	}

	static func ceil(d: double) -> long
	{
		let l = d as long
		return d > l ? l + 1 : l
	}

	// factorial

	postfix func !(lhs: long) -> long
	{
		var l = lhs
		while (lhs > 1) l *= { lhs -= 1 }
		return l
	}

	static func nPr(this: Math, n: long, r: long) -> long = n! \ (n - r)!

	static func nCr(this: Math, n: long, r: long) -> long = n! \ (r! * (n - r)!)

	// powers of two

	postfix func nextPowerOf2(this: Math, v: int) -> int
	{
		var j = v - 1
		j |= j >> 1
		j |= j >> 2
		j |= j >> 4
		j |= j >> 8
		j |= j >> 16
		return j + 1
	}

	postfix func isPowerOf2(this: Math, v: int) -> boolean = (v & -v) == v

	private const deBruijnBits: [int] = [ 0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31,
		27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9 ]

	private static func deBruijn(v: int) -> int = deBruijnBits[(v * 125613361L >> 27) as int & 0x1F]

	static func log2(this: Math, v: int) -> int = v.isPowerOf2 ? deBruijn(v) : deBruijn(nextPowerOf2(v)) - 1
}
