// GEN_NOTICE
// Timestamp: TIME_STAMP

package dyvil.math

using dyvil.Math

abstract class MathUtils
{
	private init() {} // no instances

	// min
	#for (spec <- LibraryGenConstants.MAIN_SPECS) {
		#let(T = spec['PRIMITIVE'])
		#let(WRAPPER = spec['WRAPPER'])
		#let(FLOATING_POINT = Boolean.parseBoolean(spec['IS_FLOATING_POINT']))

		static func min(this: Math, _ a: T, _ b: T, _ c: T) -> T = min(a, min(b, c))

		static func min(this: Math, _ values: T...) -> T
		{
			var min = #if (FLOATING_POINT) {WRAPPER.POSITIVE_INFINITY} #else {WRAPPER.MAX_VALUE}

			for (v <- values) if (v < min) min = v
			return min
		}

		@BytecodeName("min$_array")
		inline static func min(this: Math, _ array: [T]) -> T = min(array...)
	}

	// max
	#for (spec <- LibraryGenConstants.MAIN_SPECS) {
		#let(T = spec['PRIMITIVE'])
		#let(WRAPPER = spec['WRAPPER'])
		#let(FLOATING_POINT = Boolean.parseBoolean(spec['IS_FLOATING_POINT']))

		static func max(this: Math, _ a: T, _ b: T, _ c: T) -> T = max(a, max(b, c))

		static func max(this: Math, _ values: T...) -> T
		{
			var max = #if (FLOATING_POINT) {WRAPPER.NEGATIVE_INFINITY} #else {WRAPPER.MIN_VALUE}

			for (v <- values) if (v > max) max = v
			return max
		}

		@BytecodeName("max$_array")
		inline static func max(this: Math, _ array: [T]) -> T = max(array...)
	}

	// sum
	#for (spec <- LibraryGenConstants.MAIN_SPECS) {
		#let(T = spec['PRIMITIVE'])

		static func sum(this: Math, _ values: [T]) -> T
		{
			var sum: T = 0
			for (v <- values) sum += v
			return sum
		}
	}

	static func sum<T>(_ values: [T], implicit group: GroupAdd<T>) -> T = sum(values.asIterable(), group)

	static func sum<T>(_ values: Iterable<T>, implicit group: GroupAdd<T>) -> T
	{
		var sum = group._0
		for (k <- values) sum += k
		return sum
	}

	static func sum<R, T>(_ values: Iterable<R>, _ f: R -> T, implicit group: GroupAdd<T>) -> T
	{
		var sum = group._0
		for (k <- values) sum += f(k)
		return sum
	}

	// product
	#for (spec <- LibraryGenConstants.MAIN_SPECS) {
		#let(T = spec['PRIMITIVE'])

		static func product(this: Math, _ values: [T]) -> T
		{
			var product: T = 1
			for (v <- values) product *= v
			return product
		}
	}

	static func product<T>(_ values: [T], implicit group: GroupMultiply<T>) -> T = product(values as Iterable<T>, group)

	static func product<T>(_ values: Iterable<T>, implicit group: GroupMultiply<T>) -> T
	{
		var product = group._1
		for (k <- values) product *= k
		return product
	}

	static func product<R, T>(_ values: Iterable<R>, _ f: R -> T, implicit group: GroupMultiply<T>) -> T
	{
		var product = group._1
		for (k <- values) product *= f(k)
		return product
	}

	// average
	#for (spec <- LibraryGenConstants.MAIN_SPECS) {
		#let(T = spec['PRIMITIVE'])

		static func average(this: Math, _ values: [T]) -> double = sum(values) / (values.size as double)
	}

	// clamp
	#for (spec <- LibraryGenConstants.MAIN_SPECS) {
		#let(T = spec['PRIMITIVE'])

		infix func clamp(this: Math, _ v: T, min: T, max: T) -> T
		{
			if (v < min) return min
			if (v > max) return max
			return v
		}
	}

	// interpolate
	#for (spec <- LibraryGenConstants.MAIN_SPECS) {
		#let(T = spec['PRIMITIVE'])

		infix func interpolate(this: Math, _ v: double, min: T, max: T) -> T
		{
			if (v <= 0) return min
			if (v >= 1) return max
			return (min + (max - min) * v)#if (T != 'double') { as T}

		}
	}

	// floor & ceil

	static func floor(_ f: float) -> int
	{
		let i = f as int
		return f < i ? i - 1 : i
	}

	static func floor(_ d: double) -> long
	{
		let l = d as long
		return d < l ? l - 1 : l
	}

	static func ceil(_ f: float) -> int
	{
		let i = f as int
		return f > i ? i + 1 : i
	}

	static func ceil(_ d: double) -> long
	{
		let l = d as long
		return d > l ? l + 1 : l
	}

	// factorial

	postfix func !(_ lhs: long) -> long
	{
		var l = lhs
		while (lhs > 1)
		{
			lhs -= 1
			l *= lhs
		}
		return l
	}

	static func nPr(this: Math, n: long, r: long) -> long = n! _/ (n - r)!

	static func nCr(this: Math, n: long, r: long) -> long = n! _/ (r! * (n - r)!)

	// powers of two

	prefix func nextPowerOf2(this: Math, _ v: int) -> int
	{
		var j = v - 1
		j |= j >> 1
		j |= j >> 2
		j |= j >> 4
		j |= j >> 8
		j |= j >> 16
		return j + 1
	}

	prefix func isPowerOf2(this: Math, _ v: int) -> boolean = (v & -v) == v

	private const deBruijnBits: [int] = [ 0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31,
		27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9 ]

	private static func deBruijn(v: int) -> int = deBruijnBits[(v * 125613361L >> 27) as int & 0x1F]

	static func log2(this: Math, _ v: int) -> int = isPowerOf2(v) ? deBruijn(v) : deBruijn(nextPowerOf2(v)) - 1
}
