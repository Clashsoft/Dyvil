package dyvil.math

@LiteralConvertible.FromDouble
@LiteralConvertible.FromTuple
public case class Complex(final double real, final double imag)
{
	public static let i = Complex(0, 1)

	// Conversion Methods

	static inline func apply(double real) -> Complex = new Complex(real, 0)

	@OverloadPriority
	static func apply(double real, double imag) -> Complex = new Complex(real, imag)

	@BytecodeName("fromPolar")
	static func apply(double length, double argument) -> Complex = new Complex(length * Math.cos(argument), length * Math.sin(argument))

	static implicit inline infix func toComplex(double d) -> Complex = Complex(d, 0)

	// Basic Operators

	public func length() -> double
	{
		let r = this.real
		let i = this.imag
		return Math.sqrt(r * r + i * i)
	}

	public func argument() -> double = Math.atan(this.imag / this.real)

	// Prefix Operators

	prefix func -(Complex c) -> Complex = Complex(-c.real, c.imag)

	prefix func ~(Complex c) -> Complex = Complex(c.real, -c.imag)

	// Infix Operators

	infix func +(Complex lhs, Complex rhs) -> Complex = Complex(lhs.real + rhs.real, lhs.imag + rhs.imag)

	infix func -(Complex lhs, Complex rhs) -> Complex = Complex(lhs.real - rhs.real, lhs.imag - rhs.imag)

	infix func *(Complex lhs, Complex rhs) -> Complex
	{
		let lr = lhs.real
		let li = lhs.imag
		let rr = rhs.real
		let ri = rhs.imag
		return Complex(lr * rr - ri * li, li * rr + lr * ri)
	}

	infix func /(Complex lhs, Complex rhs) -> Complex
	{
		let lr = lhs.real
		let li = lhs.imag
		let rr = rhs.real
		let ri = rhs.imag
		let d = 1.0 / (rr * rr + ri * ri)
		return Complex((lr * rr + li * ri) * d, (li * rr - lr * ri) * d)
	}

	override func toString() -> String = this.imag >= 0 ? "\(this.real)+\(this.imag)i" : "\(this.real)\(this.imag)i"
}
