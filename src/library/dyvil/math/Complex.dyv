package dyvil.math

@LiteralConvertible.FromDouble
@LiteralConvertible.FromTuple
public case class Complex(let real: double, let imag: double)
{
	public const i = Complex(0, 1)

	// Conversion Methods

	implicit static inline func apply(real: double) -> Complex = new Complex(real, 0)

	@OverloadPriority
	static inline func apply(real: double, imag: double) -> Complex = new Complex(real, imag)

	@BytecodeName("fromPolar")
	static inline func apply(explicit length: double, explicit argument: double) -> Complex
		= new Complex(length * Math.cos(argument), length * Math.sin(argument))

	// Basic Operations

	func length()   -> double = Math.hypot(this.real, this.imag)

	func argument() -> double = Math.atan2(this.imag, this.real)

	// Prefix Operators

	inline prefix func +(rhs: Complex) -> Complex = rhs

	prefix func -(rhs: Complex) -> Complex = Complex(-rhs.real, -rhs.imag)

	prefix func ~(rhs: Complex) -> Complex = Complex(+rhs.real, -rhs.imag)

	// Additive Operators

	infix func +(lhs: Complex, rhs: Complex) -> Complex = Complex(lhs.real + rhs.real, lhs.imag + rhs.imag)

	infix func -(lhs: Complex, rhs: Complex) -> Complex = Complex(lhs.real - rhs.real, lhs.imag - rhs.imag)

	// Multiplicative Operators

	infix func *(lhs: double, rhs: Complex)  -> Complex = Complex(lhs * rhs.real, lhs * rhs.imag)

	infix func *(lhs: Complex, rhs: double)  -> Complex = Complex(lhs.real * rhs, lhs.imag * rhs)

	infix func *(lhs: Complex, rhs: Complex) -> Complex
	{
		let lr = lhs.real
		let li = lhs.imag
		let rr = rhs.real
		let ri = rhs.imag

		let real = lr * rr - ri * li
		let imag = li * rr + lr * ri
		return Complex(real, imag)
	}

	infix func /(lhs: Complex, rhs: double)  -> Complex = Complex(lhs.real / rhs, lhs.imag / rhs)

	infix func /(lhs: double, rhs: Complex)  -> Complex
	{
		let rr = rhs.real
		let ri = rhs.imag
		let d = lhs / (rr * rr + ri * ri)
		return Complex(rr * d, -ri * d)
	}

	infix func /(lhs: Complex, rhs: Complex) -> Complex
	{
		let lr = lhs.real
		let li = lhs.imag
		let rr = rhs.real
		let ri = rhs.imag
		let d = 1.0 / (rr * rr + ri * ri)
		return Complex((lr * rr + li * ri) * d, (li * rr - lr * ri) * d)
	}

	// Exponentiative Operators

	// (r * exp(arg * i)) ^ b = r ^ b * exp(arg * i * b)
	infix func **(lhs: Complex, rhs: double) -> Complex = Complex(length: lhs.length ** rhs, argument: lhs.argument * rhs)

	// Other Methods

	override func toString() -> String
	{
		if (this.imag == 0) return "\(this.real)"
		if (this.real == 0) return "\(this.imag)i"
		if (this.imag >= 0) return "\(this.real) + \(this.imag)i"
		                    return "\(this.real) - \(-this.imag)i"
	}
}
