// GEN_NOTICE
// Timestamp: TIME_STAMP

package dyvil.array

import dyvil.collection.immutable.ArrayList

#if(HAS_RANGE_CLASS){import dyvil.collection.range.closed.#(TYPE_NAME)Range}

import dyvil.ref.#(TYPE_NAME)Ref
import dyvil.ref.array.#(TYPE_NAME)ArrayRef

import java.util.Arrays
import java.util.function._
import java.lang.reflect.Array

import static dyvil.reflect.Opcodes._

public abstract class #(TYPE_NAME)Array
{
	#import("Base.dgs")

	#define(REIFIED) {@Reified(Reified.Type.OBJECT_CLASS)}
	#if (IS_OBJECT) {
		#define(GENERIC) {<T>}
		#define(GENERIC_2) {<T, REIFIED U>}
		#define(GENERIC_REIFIED) {<REIFIED T>}
		#define(APPLY_T) {apply<T>}
		#define(APPLY_WITH_SIZE) {apply(size, componentType: array.componentType)}
	}
	#else {
		#define(GENERIC) {}
		#define(GENERIC_2) {<REIFIED U>}
		#define(GENERIC_REIFIED) {}
		#define(APPLY_T) {apply}
		#define(APPLY_WITH_SIZE) {apply(size)}
	}

	private init() {} // no instances

	#if (IS_OBJECT) {
		public const EMPTY: [final Object!] = []
	}
	#else {
		public const EMPTY: [final PRIMITIVE] = []
	}

	static inline func apply GENERIC_REIFIED() -> [PRIMITIVE] = []

	#if (IS_OBJECT) {
		static inline func apply GENERIC_REIFIED(size: int) -> [T] = apply<T>(size, componentType: class T)

		@BytecodeName("ofType")
		static func apply<T>(size: int, componentType: Class<T>) -> [T]
			= Array.newInstance(componentType, size) as [T]
	}
	#else {
		static inline func apply(size: int) -> [PRIMITIVE] = new [PRIMITIVE](size)
	}

	static inline func apply GENERIC(array: [PRIMITIVE]) -> [PRIMITIVE] = array.copy

	#if (HAS_RANGE_CLASS) {
		static func apply GENERIC(range: #(TYPE_NAME)Range) -> [PRIMITIVE] = range.to#(TYPE_NAME)Array()
	}

	static func apply GENERIC_REIFIED(size: int, repeatedValue: PRIMITIVE) -> [PRIMITIVE]
	{
		let array = APPLY_T(size)
		for (i <- 0 ..< size) array[i] = repeatedValue
		return array
	}

	static func apply GENERIC_REIFIED(size: int, valueSupplier: SUPPLIER) -> [PRIMITIVE]
	{
		let array = APPLY_T(size)
		for (i <- 0 ..< size) array[i] = valueSupplier.SUPPLIER_GET()#if (SUPPLIER_CAST) { as PRIMITIVE}

		return array
	}

	static func apply GENERIC_REIFIED(size: int, valueMapper: INDEXED_SUPPLIER) -> [PRIMITIVE]
	{
		let array = APPLY_T(size)
		for (i <- 0 ..< size) array[i] = valueMapper.INDEXED_SUPPLIER_APPLY(i)#if(INDEXED_SUPPLIER_CAST){ as PRIMITIVE}

		return array
	}

	#if (IS_RANGEABLE) {
		@BytecodeName("rangeClosed")
		static func apply GENERIC(from: PRIMITIVE, to: PRIMITIVE) -> [PRIMITIVE]
		{
			let array = #if (RANGE_CAST) {apply((to - from + 1) as int)} #else {apply(to - from + 1)}

			var index = 0

			for (i <- from .. to) array[index++] = i
			return array
		}

		@BytecodeName("rangeOpen")
		static func range GENERIC(from: PRIMITIVE, explicit toExclusive: PRIMITIVE) -> [PRIMITIVE]
		{
			let array = #if (RANGE_CAST) {apply((toExclusive - from) as int)} #else {apply(toExclusive - from)}

			var index = 0

			for (i <- from ..< toExclusive) array[index++] = from
			return array
		}
	}

	// Basic Array Operations

	@Deprecated(replacements: [ "[PRIMITIVE].size() -> int" ])
	@Intrinsic([ LOAD_0, ARRAYLENGTH ])
	postfix func length GENERIC(array: [PRIMITIVE]) -> int = array.size

	@Intrinsic([ LOAD_0, ARRAYLENGTH ])
	postfix func size GENERIC(array: [PRIMITIVE]) -> int = array.size

	@Intrinsic([ LOAD_0, ARRAYLENGTH, EQ0 ])
	postfix func isEmpty GENERIC(array: [PRIMITIVE]) -> boolean = array.isEmpty

	@Intrinsic([ LOAD_0, LOAD_1, ARRAY_LOAD_INSN ])
	infix func subscript GENERIC(array: [PRIMITIVE], index: int) -> PRIMITIVE = array[index]

	infix func subscript GENERIC(array: [PRIMITIVE], range: Range<int>) -> [PRIMITIVE]
	{
		let size = range.size
		let result = APPLY_WITH_SIZE

		System.arraycopy(array, range.first, result, 0, size)
		return result
	}

	@Mutating
	@Intrinsic([ LOAD_0, LOAD_1, LOAD_2, ARRAY_STORE_INSN ])
	infix func subscript_= GENERIC(array: [PRIMITIVE], index: int, newValue: PRIMITIVE) -> void
		= array[index] = newValue

	@Mutating
	infix func subscript_= GENERIC(array: [PRIMITIVE], range: Range<int>, newValues: [PRIMITIVE]) -> void
		= System.arraycopy(newValues, 0, array, range.first, range.size)

	@Mutating
	infix func subscript_& GENERIC(array: [PRIMITIVE], index: int) -> #(TYPE_NAME)Ref
		= new #(TYPE_NAME)ArrayRef(array, index)

	infix func forEach GENERIC(array: [PRIMITIVE], action: CONSUMER) -> void
		= for (value <- array) action.CONSUMER_ACCEPT(value)

	#if (IS_OBJECT) {
		// Component Types

		postfix func componentType<T>(array: [T]) -> Class<T> = array.getClass.getComponentType as Class<T>

		postfix func deepComponentType<T>(array: [T]) -> Class<_>
		{
			var ret: Class<_> = array.dynamicClass
			while (true)
			{
				var componentType = ret.getComponentType
				if (componentType == null)
				{
					break
				}
				ret = componentType
			}
			return ret
		}
	}

	// Operators

	@Intrinsic([], compilerCode: Intrinsic.ARRAY_SPREAD)
	postfix func `...` GENERIC(array: [PRIMITIVE]) -> [PRIMITIVE] = array

	infix inline func == GENERIC(lhs: [PRIMITIVE], rhs: [PRIMITIVE]) -> boolean = Arrays.equals(lhs, rhs)

	infix inline func != GENERIC(lhs: [PRIMITIVE], rhs: [PRIMITIVE]) -> boolean = !Arrays.equals(lhs, rhs)

	infix func added GENERIC(array: [PRIMITIVE], value: PRIMITIVE) -> [PRIMITIVE]
	{
		let size = array.size
		let result = #if (IS_OBJECT) {apply(size + 1, componentType: array.componentType)} #else {apply(size + 1)}

		System.arraycopy(array, 0, result, 0, size)
		result[size] = value
		return result
	}

	infix func union GENERIC(array: [PRIMITIVE], with: [PRIMITIVE]) -> [PRIMITIVE]
	{
		let size1 = array.size
		let size2 = with.size
		let size = size1 + size2
		let result = APPLY_WITH_SIZE

		System.arraycopy(array, 0, result, 0, size1)
		System.arraycopy(with, 0, result, size1, size2)
		return result
	}

	infix func removed GENERIC(array: [PRIMITIVE], value: PRIMITIVE) -> [PRIMITIVE]
	{
		var size = array.size

		// Calculate number of elements in new array
		for (element <- array) if (element == value) size--

		let result = APPLY_WITH_SIZE
		var index = 0

		for (element <- array) if (element != value) result[index++] = element
		return result
	}

	infix func difference GENERIC(array: [PRIMITIVE], from: [PRIMITIVE]) -> [PRIMITIVE]
	{
		let size = array.size
		let result = APPLY_WITH_SIZE
		var index = 0

		for (v <- array) if (!from.contains(v)) result[index++] = v
		return result.trim(index)
	}

	infix func intersection GENERIC(array: [PRIMITIVE], with: [PRIMITIVE]) -> [PRIMITIVE]
	{
		let size = array.size
		let result = APPLY_WITH_SIZE
		var index = 0

		for (v <- array) if (with.contains(v)) result[index++] = v
		return result.trim(index)
	}

	#if (IS_OBJECT /* Object Arrays do not need a specialized mapped method */ ) {}
	#else {
		infix func mapped(array: [PRIMITIVE], mapper: MAPPER) -> [PRIMITIVE]
		{
			let size = array.size
			let result = apply(size)

			for (i <- 0 ..< size) result[i] = mapper.MAPPER_APPLY(array[i])#if (MAPPER_CAST) { as PRIMITIVE}

			return result
		}
	}

	@OverloadPriority
	infix func mapped GENERIC_2(array: [PRIMITIVE], mapper: TO_MAPPER U TO_MAPPER_END) -> [U]
	{
		let size = array.size
		let result = ObjectArray<U>(size)
		for (i <- 0 ..< size) result[i] = mapper.TO_MAPPER_APPLY(array[i])
		return result
	}

	#if (IS_OBJECT /* Object Arrays do not need a specialized flatMapped method */) {}
	#else {
		infix func flatMapped(array: [PRIMITIVE], mapper: TO_MAPPER [PRIMITIVE] TO_MAPPER_END) -> [PRIMITIVE]
		{
			var size = 0
			var result = apply(array.size << 2)

			for (v <- array)
			{
				let inner = mapper.TO_MAPPER_APPLY(v)
				let newSize = inner.size

				if (size + newSize >= result.size)
				{
					result = result.copy((size + newSize) << 1)
				}

				System.arraycopy(inner, 0, result, size, newSize)
				size += newSize
			}

			return result.trim(size)
		}
	}

	@OverloadPriority
	infix func flatMapped GENERIC_2(array: [PRIMITIVE], mapper: TO_MAPPER +Iterable<+U> TO_MAPPER_END) -> [U]
	{
		let list = new mutable.ArrayList<U>(array.size << 2)

		for (value <- array) list.addAll(mapper.TO_MAPPER_APPLY(value))
		return list.toArray<U>(class U)
	}

	infix func filtered GENERIC(array: [PRIMITIVE], condition: PREDICATE) -> [PRIMITIVE]
	{
		let size = array.size
		let result = APPLY_WITH_SIZE
		var index = 0

		for (v <- array) if (condition.PREDICATE_TEST(v)) result[index++] = v
		return result.trim(index)
	}

	infix func sorted GENERIC(array: [PRIMITIVE]) -> [PRIMITIVE]
	{
		#if (IS_BOOLEAN) {
			let size = array.size
			let result = new [PRIMITIVE](size)

			// Count the number of 'false' entries in the array
			var falseEntries = 0

			for (value <- array) if (!value) falseEntries++

			// Make the remaining elements of the result true
			for (i <- falseEntries ..< size) result[i] = true
			return result
		}
		#else {
			let result = array.copy
			Arrays.sort(result)
			return result
		}
	}

	// Search Operations

	infix inline func contains GENERIC(array: [PRIMITIVE], value: PRIMITIVE) -> boolean = array.indexOf(value, 0) >= 0

	infix inline func indexOf GENERIC(array: [PRIMITIVE], value: PRIMITIVE) -> int = array.indexOf(value, 0)

	infix func indexOf GENERIC(array: [PRIMITIVE], value: PRIMITIVE, startIndex: int) -> int
	{
		while (startIndex < array.size)
		{
			if (array[startIndex] == value)
			{
				return startIndex
			}
			startIndex++
		}
		return -1
	}

	infix func lastIndexOf GENERIC(array: [PRIMITIVE], value: PRIMITIVE) -> int = array.lastIndexOf(value, array.size - 1)

	infix func lastIndexOf GENERIC(array: [PRIMITIVE], value: PRIMITIVE, startIndex: int) -> int
	{
		while (startIndex >= 0)
		{
			if (array[startIndex] == value) return startIndex
			startIndex--
		}
		return -1
	}

	// Copying

	@Deprecated(replacements: [ "[PRIMITIVE].copy() -> [PRIMITIVE]" ])
	infix inline func clone GENERIC(array: [PRIMITIVE]) -> [PRIMITIVE] = array.copy

	infix inline func copy GENERIC(array: [PRIMITIVE]) -> [PRIMITIVE] = (array as Object).clone as [PRIMITIVE]

	infix func copy GENERIC(array: [PRIMITIVE], withSize size: int) -> [PRIMITIVE]
	{
		let result = APPLY_WITH_SIZE
		System.arraycopy(array, 0, result, 0, array.size)
		return result
	}

	infix func trim GENERIC(array: [PRIMITIVE], toSize size: int) -> [PRIMITIVE]
		= array.size == size ? array : array.copy(size)

	#if (IS_OBJECT) {}
	#else {
		infix func boxed(array: [PRIMITIVE]) -> [WRAPPER]
		{
			let size = array.size
			let boxed = new [WRAPPER](size)

			for (i <- 0 ..< size) boxed[i] = array[i]
			return boxed
		}
	}

	implicit infix inline func asIterable GENERIC(array: [PRIMITIVE]) -> Iterable<PRIMITIVE> = array.toList

	implicit infix inline func asList GENERIC(array: [final PRIMITIVE]) -> ImmutableList<PRIMITIVE> = array.toList

	infix func toList GENERIC(array: [PRIMITIVE]) -> ImmutableList<PRIMITIVE>
		= #if (IS_OBJECT) {new ArrayList<PRIMITIVE>(array)} #else {new ArrayList<PRIMITIVE>(array.boxed, trusted: true)}


	// equals, hashCode and toString

	#if (IS_OBJECT) {
		// equals

		infix inline func equals(array: [Object!]!, other: [Object!]!) -> boolean = Arrays.equals(array, other)

		infix inline func deepEquals(array: [Object!]!, other: [Object!]!) -> boolean = Arrays.deepEquals(array, other)

		infix func deepEquals(obj: Object!, other: Object!) -> boolean = [obj].deepEquals([other])

		// hashCode

		postfix inline func hashCode(array: [Object!]!) -> int = Arrays.hashCode(array)

		postfix inline func deepHashCode(array: [Object!]!) -> int = Arrays.deepHashCode(array)

		postfix func deepHashCode(obj: Object!) -> int = [obj].deepHashCode
	}
	#else {
		infix inline func equals(array: [PRIMITIVE]!, other: [PRIMITIVE]!) -> boolean = Arrays.equals(array, other)

		infix inline func hashCode(array: [PRIMITIVE]!) -> int = Arrays.hashCode(array)
	}

	// toString

	infix func toString GENERIC(array: [PRIMITIVE]!) -> String
	{
		if (array == null) return 'null'

		let size = array!!.size
		if (size == 0) return '[]'

		let builder = new StringBuilder()
		append(array!!, size, builder)
		return builder.toString!!
	}

	infix func toString GENERIC(array: [PRIMITIVE]!, builder: StringBuilder) -> void
	{
		if (array == null)
		{
			builder.append('null')
			return
		}

		let size = array!!.size
		if (size == 0)
		{
			builder.append('[]')
			return
		}

		append(array!!, size, builder)
	}

	private static func append GENERIC(array: [PRIMITIVE], size: int, builder: StringBuilder) -> void
	{
		builder.append('[').append(array[0])
		for (i <- 1 ..< size) builder.append(", ").append(array[i])
		builder.append(']')
	}

	#if (IS_OBJECT) {
		postfix func deepToString(array: [Object!]!) -> String
		{
			if (array == null) return 'null'

			let size = array!!.size
			if (size == 0) return '[]'

			let builder = new StringBuilder()
			deepAppend(array!!, size, builder)
			return builder.toString!!
		}

		infix func deepToString(array: [Object!]!, builder: StringBuilder) -> void
		{
			if (array == null)
			{
				builder.append('null')
				return
			}

			let size = array!!.size
			if (size <= 0)
			{
				builder.append('[]')
				return
			}

			deepAppend(array!!, size, builder)
		}

		private static func deepAppend(array: [Object!], size: int, builder: StringBuilder) -> void
		{
			builder.append('[')
			array[0].deepToString(builder)
			for (i <- 1 ..< size)
			{
				builder.append(', ')
				array[i].deepToString(builder)
			}
			builder.append(']')
		}

		postfix func deepToString(obj: Object!) -> String
		{
			if (obj == null) return 'null'

			let objectClass = obj!!.dynamicClass
			if (!objectClass.isArray) return obj!!.toString

			#for (spec <- PRIMITIVE_SPECS) {
				#import(spec)
				if (objectClass === class [PRIMITIVE])
				{
					return (obj as [PRIMITIVE]).toString
				}
			}

			return (obj as [Object!]).deepToString
		}

		infix func deepToString(obj: Object!, builder: StringBuilder) -> void
		{
			if (obj == null)
			{
				builder.append('null')
				return
			}

			let objectClass = obj!!.dynamicClass
			if (!objectClass.isArray)
			{
				builder.append(obj)
				return
			}

			#for (spec <- PRIMITIVE_SPECS) {
				#import(spec)
				if (objectClass === class [PRIMITIVE])
				{
					(obj as [PRIMITIVE]).toString(builder)
					return
				}
			}

			(obj as [Object!]).deepToString(builder)
		}
	}
}
