package dyvil.lang

using   dyvil.reflect.Opcodes._
import  dyvil.collection.range.specialized.IntRange

public abstract class Ints
{
	private init() {}

	// Unary Operators

	@Intrinsic([ LOAD_0 ])
	prefix func +(rhs: int) -> int = rhs

	@Intrinsic([ LOAD_0, INEG ])
	prefix func -(rhs: int) -> int = -rhs

	@Intrinsic([ LOAD_0, INOT ])
    prefix func ~(rhs: int) -> int = ~rhs

    // Relational Operators

	@Intrinsic([ LOAD_0, LOAD_1, ICMPEQ ])
	infix func ==(lhs: int, rhs: int) -> boolean = lhs == rhs

	@Intrinsic([ LOAD_0, LOAD_1, ICMPNE ])
	infix func !=(lhs: int, rhs: int) -> boolean = lhs != rhs

	@Intrinsic([ LOAD_0, LOAD_1, ICMPLT ])
	infix func <(lhs: int, rhs: int) -> boolean = lhs < rhs

	@Intrinsic([ LOAD_0, LOAD_1, ICMPLE ])
	infix func <=(lhs: int, rhs: int) -> boolean = lhs <= rhs

	@Intrinsic([ LOAD_0, LOAD_1, ICMPGT ])
	infix func >(lhs: int, rhs: int) -> boolean = lhs > rhs

	@Intrinsic([ LOAD_0, LOAD_1, ICMPGE ])
	infix func >=(lhs: int, rhs: int) -> boolean = lhs >= rhs

	// Additive Operators

	@Intrinsic([ LOAD_0, LOAD_1, IADD ])
	infix func +(lhs: int, rhs: int) -> int = lhs + rhs

	@Intrinsic([ LOAD_0, LOAD_1, ISUB ])
	infix func -(lhs: int, rhs: int) -> int = lhs - rhs

	// Multiplicative Operators

	@Intrinsic([ LOAD_0, LOAD_1, IMUL ])
	infix func *(lhs: int, rhs: int) -> int = lhs * rhs

	infix func **(lhs: int, rhs: int) -> int = dyvil.math.PowImpl.pow(lhs, rhs) as int

	// Division Operators

	@Intrinsic([ LOAD_0, I2F, LOAD_1, I2F, FDIV ])
	infix func /(lhs: int, rhs: int) -> float = lhs / rhs

	@Intrinsic([ LOAD_0, LOAD_1, IREM ])
	infix func %(lhs: int, rhs: int) -> int = lhs % rhs

	// divmod
	infix func /%(lhs: int, rhs: int) -> (int, int) = (lhs _/ rhs, lhs % rhs)

	@Deprecated(replacements: ["_/ (int, int): int"])
	@Intrinsic([ LOAD_0, LOAD_1, IDIV ])
	infix func \(lhs: int, rhs: int) -> int = lhs _/ rhs

	// floordiv
	@Intrinsic([ LOAD_0, LOAD_1, IDIV ])
	infix func _/(lhs: int, rhs: int) -> int = lhs _/ rhs

	// Bitwise Operators

	@Intrinsic([ LOAD_0, LOAD_1, IAND ])
	infix func &(lhs: int, rhs: int) -> int = lhs & rhs

	@Intrinsic([ LOAD_0, LOAD_1, IOR ])
	infix func |(lhs: int, rhs: int) -> int = lhs | rhs

	@Intrinsic([ LOAD_0, LOAD_1, IXOR ])
	infix func ^(lhs: int, rhs: int) -> int = lhs ^ rhs

	// Shift Operators

	@Intrinsic([ LOAD_0, LOAD_1, ISHL ])
	infix func <<(lhs: int, rhs: int) -> int = lhs << rhs

	@Intrinsic([ LOAD_0, LOAD_1, ISHR ])
	infix func >>(lhs: int, rhs: int) -> int = lhs >> rhs

	@Intrinsic([ LOAD_0, LOAD_1, IUSHR ])
	infix func >>>(lhs: int, rhs: int) -> int = lhs >>> rhs

	// Range Operators

	inline infix func ..(lhs: int, rhs: int) -> IntRange = IntRange(lhs, to: rhs)

	inline infix func ..<(lhs: int, rhs: int) -> IntRange = IntRange(lhs, toExclusive: rhs)

	// Other Operators

	inline static func |_|(lhs: int) -> int = Math.abs(lhs)
}
