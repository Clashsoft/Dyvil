package dyvil.lang

import dyvilx.tools.parsing.lexer.StringLiterals
import java.lang.reflect.Array

/**
 * The **Representable** class provides a mechanism for getting the Dyvil code representation of a runtime object.
 * A sub-class of `Representable` implements the {@link represent(to:)} method, which writes the representation
 * to a {@link StringBuilder} object. The {@link representation()} method allows access to the representation string
 * without having to create an extra `StringBuilder` object.
 *
 * This class also exposes extension methods to the {@link String} class. They allow the user to access the
 * representation of an arbitrary object using the `String(representing: value)` syntax. Representation computation
 * for arbitrary objects is described in the docs of the {@link String.apply(representing:)} method.
 */
interface Representable
{
	/**
	 * Returns the representation of this {@link Representable}.
	 * This method does not need to be overriden as long as {@link represent(to:)` is implemented.
	 */
	var representation: String { get: String(representing: this) }

	/**
	 * Writes the representation of this object to the specified {@link StringBuilder}.
	 */
	func represent(to _ : StringBuilder) -> void

	/**
	 * Returns the representation of the `representing:` argument. Also accepts `null`, in which case the
	 * representation is `null`.
	 */
	@BytecodeName('repr')
	static extension func apply(this: String, explicit representing value: Representable!) -> String
		= if let value = value { String(representing: value) } else { 'null' }

	/**
	 * Returns the representation of the argument as defined by the {@link represent(to:)} method.
	 */
	@BytecodeName('repr_nonNull')
	static extension func apply(this: String, explicit representing value: Representable) -> String
	{
		let builder = new StringBuilder
		value.represent(to: builder)
		return builder.toString
	}

	/**
	 * Returns the representation of the `representing:` argument, as calculated according to the following algorithm:
	 *
	 * - If the argument is `null`, the result is `null`.
	 * - If the argument is an instance of the type `Representable` or a sub-type, the result is the same as that of a
	 *   call to {@link representation}.
	 * - If the argument is a primitive value (i.e. an instance of a primitive value class) or of type {@link String},
	 *   the result is a string that, when used as Dyvil code, would produce that value.
	 * - If the argument is of type {@link java.math.BigInteger} or {@link java.math.BigDecimal}, the result is
	 *   `class-name(to-string)`, where `class-name` is one of the above class names and
	 *   `to-string` is the result of a call to {@link Object#toString() toString} of the argument.
	 * - If the argument is an array, the result is `[representation-0, ..., representation-(n-1)]`, where
	 *   `representation-i` is the representation of the `i`-th element of the array, and `n` is the array length.
	 * - Otherwise, the result is `class-name(field-name-1: field-value-1, ..., field-name-n: field-value-n)`, where
	 *   `class-name` the fully qualified canonical name of the argument type, `field-name-i` is the name of the `i`-th
	 *   field and `field-value-i` is the representation of the `i`-th fields value. This includes fields from all
	 *   super-types of the argument type, but no `static` fields.
	 *
	 * Values that have already been formatted are displayed as `...` to avoid infinite recursion for arrays or classes
	 * containing references to themselves or other types of cyclic references.
	 */
	@BytecodeName('repr')
	static extension func apply(this: String, explicit representing value: any!) -> String
	{
		let builder = new StringBuilder
		reflect(value, builder, new mutable.IdentityHashSet<any>)
		return builder.toString
	}

	private static func reflect(value: any!, builder: StringBuilder, dejaVu: Set<any>) -> void
	{
		if let repr = value as? Representable
		{
			repr.represent(to: builder)
		}
		else if (let value = value)
		{

			let valueClass = value.dynamicClass
			if (!reflectSimple(value, valueClass, builder, dejaVu))
			{
				reflectFull(value, valueClass, builder, dejaVu)
			}
		}
		else
		{
			builder.append('null')
		}
	}

	private static func reflectSimple(value: any, valueClass: Class<_>, builder: StringBuilder, dejaVu: Set<any>) -> boolean
	{
		if (valueClass.isArray)
		{
			let size = Array.getLength(value)
			if (size == 0)
			{
				builder.append('[]')
				return true
			}

			builder.append('[')
			reflect(Array.get(value, 0), builder, dejaVu)
			for (i <- 1 ..< size)
			{
				builder.append(', ')
				reflect(Array.get(value, i), builder, dejaVu)
			}
			builder.append(']')
			return true
		}
		if (valueClass == class<java.math.BigInteger> || valueClass == class<java.math.BigDecimal>)
		{
			builder.append(valueClass.getCanonicalName()).append('(').append(value).append(')')
			return true
		}
		if (!valueClass.getName().startsWith("java.lang."))
		{
			return false
		}
		match (valueClass.getSimpleName())
		{
			case 'Boolean' | 'Byte' | 'Short' | 'Integer' => builder.append(value)

			case 'Long'      => builder.append(value).append('L')
			case 'Float'     => builder.append(value).append('F')
			case 'Double'    => builder.append(value).append('D')
			case 'Character' => StringLiterals.appendCharLiteral(value.toString, builder)
			case 'String'    => StringLiterals.appendStringLiteral(value.toString, builder)

			case _ => return false // other type -> use reflectFull
		}

		return true // only reached when one of the above patterns matched
	}

	private static func reflectFull(value: any, valueClass: Class<_>, builder: StringBuilder, dejaVu: Set<any>) -> void
	{
		if (!dejaVu.add(value))
		{
			builder.append('...')
			return
		}

		builder.append(valueClass.getCanonicalName()).append('(')

		for (var currentType: Class<_>! = valueClass; currentType != null; currentType = currentType.getSuperclass())
		{
			for (field <- currentType!!.getDeclaredFields)
			{
				if ((field.getModifiers() & dyvil.reflect.Modifiers.STATIC) != 0) continue

				builder.append(field.getName()).append(': ')

				try
				{
					field.setAccessible(true)
					reflect(field.get(value), builder, dejaVu)
					field.setAccessible(false)
				}
				catch (ex: Exception)
				{
					builder.append("<error>")
				}

				builder.append(', ')
			}
		}

		// delete extra ', '
		let length = builder.length
		if (builder.charAt(length - 2) == ',') { builder.delete(length - 2, length) }

		builder.append(')')
	}
}
