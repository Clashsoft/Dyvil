package dyvil.lang

using	dyvil.reflect.Opcodes._

public final class Primitives
{
	private static final [int] LOAD_CALL = [ LOAD_0, INVOKESTATIC, 0, 1, 2 ]
	
	// Wrapper and Unwrapper Methods

	@Intrinsic(value: [ INVOKESTATIC, 0, 1, 2 ], strings : [ "dyvil/lang/Void", "apply", "()Ldyvil/lang/Void;" ])
	public static Void Void() = Void()

	@Intrinsic([ /* NOOP */ ])
	public static void toVoid(Void value) = ()
	
	@Intrinsic(value: LOAD_CALL, strings : [ "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean;" ])
	public static Boolean Boolean(boolean value) = Boolean(value)

	public static boolean toBoolean(Boolean value) = if (value == null) false else value.booleanValue

	@Intrinsic(value: LOAD_CALL, strings : [ "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte;" ])
    public static Byte Byte(byte value) = Byte(value)

	public static byte toByte(Byte value) = if (value == null) 0 else value.byteValue

	@Intrinsic(value: LOAD_CALL, strings : [ "java/lang/Short", "valueOf", "(S)Ljava/lang/Short;" ])
	public static Short Short(short value) = Short(value)

	public static short toShort(Short value) = if (value == null) 0 else value.shortValue

	@Intrinsic(value: LOAD_CALL, strings : [ "java/lang/Character", "valueOf", "(C)Ljava/lang/Character;" ])
	public static Char Char(char value) = Char(value)

	public static char toChar(Char value) = if (value == null) 0 else value.charValue

	@Intrinsic(value: LOAD_CALL, strings : [ "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;" ])
	public static Int Int(int value) = Int(value)

	public static int toInt(Int value) = if (value == null) 0 else value.intValue

	@Intrinsic(value: LOAD_CALL, strings : [ "java/lang/Long", "valueOf", "(J)Ljava/lang/Long;" ])
	public static Long Long(long value) = Long(value)

	public static long toLong(Long value) = if (value == null) 0 else value.longValue
	
	@Intrinsic(value: LOAD_CALL, strings : [ "java/lang/Float", "valueOf", "(F)Ljava/lang/Float;" ])
	public static Float Float(float value) = Float(value)

	public static float toFloat(Float value) = if (value == null) 0 else value.floatValue

	@Intrinsic(value: LOAD_CALL, strings : [ "java/lang/Double", "valueOf", "(D)Ljava/lang/Double;" ])
	public static Double Double(double value) = Double(value)

	public static double toDouble(Double value) = if (value == null) 0 else value.doubleValue
	
	// Boolean Operators
	
	@Intrinsic([ LOAD_0, BNOT ])
	public prefix func !(boolean v): boolean = !v
	
	@Intrinsic([ LOAD_0, LOAD_1, ICMPEQ ])
	public infix func ==(boolean v1, boolean v2): boolean = v1 == v2

	@Intrinsic([ LOAD_0, LOAD_1, ICMPNE ])
	public infix func !=(boolean v1, boolean v2): boolean = v1 != v2

	@Intrinsic([ LOAD_0, LOAD_1, IAND ])
	public infix func &(boolean v1, boolean v2): boolean = v1 && v2

	@Intrinsic([ LOAD_0, LOAD_1, IOR ])
	public infix func |(boolean v1, boolean v2): boolean = v1 || v2

	@Intrinsic([ LOAD_0, LOAD_1, IXOR ])
	public infix func ^(boolean v1, boolean v2): boolean = v1 ^ v2

	@Intrinsic([ LOAD_0, BNOT, LOAD_1, IOR ])
	public infix func ==>(boolean v1, boolean v2): boolean = !v1 || v2

	@Intrinsic([ LOAD_0, LOAD_1, BNOT, IOR ])
	public infix func <==(boolean v1, boolean v2): boolean = v1 || !v2

	@Intrinsic([ LOAD_0, LOAD_1, ICMPEQ ])
	public infix func <=>(boolean v1, boolean v2): boolean = v1 == v2

	// Boolean Methods

	public infix int compareTo(boolean b1, boolean b2) = if (b1 == b2) 0 else if (b1) 1 else -1

	public postfix String toString(boolean value) = if (value) "true" else "false"

	public postfix int hashCode(boolean value) = if (value) 1231 else 1237

	public infix boolean equals(boolean b1, boolean b2) = b1 == b2

	// Int Operators

	@Intrinsic([ LOAD_0 ])
	public prefix func +(int value): int = value

	@Intrinsic([ LOAD_0, INEG ])
	public prefix func -(int value): int = -value

	@Intrinsic([ LOAD_0, INOT ])
    public prefix func ~(int value): int = ~value

	@Intrinsic([ LOAD_0, LOAD_1, ICMPEQ ])
	public infix func ==(int v1, int v2): boolean = v1 == v2

	@Intrinsic([ LOAD_0, LOAD_1, ICMPNE ])
	public infix func !=(int v1, int v2): boolean = v1 != v2

	@Intrinsic([ LOAD_0, LOAD_1, ICMPLT ])
	public infix func <(int v1, int v2): boolean = v1 < v2

	@Intrinsic([ LOAD_0, LOAD_1, ICMPLE ])
	public infix func <=(int v1, int v2): boolean = v1 <= v2

	@Intrinsic([ LOAD_0, LOAD_1, ICMPGT ])
	public infix func >(int v1, int v2): boolean = v1 > v2

	@Intrinsic([ LOAD_0, LOAD_1, ICMPGE ])
	public infix func >=(int v1, int v2): boolean = v1 >= v2

	@Intrinsic([ LOAD_0, LOAD_1, IADD ])
	public infix func +(int v1, int v2): int = v1 + v2

	@Intrinsic([ LOAD_0, LOAD_1, ISUB ])
	public infix func -(int v1, int v2): int = v1 - v2

	@Intrinsic([ LOAD_0, LOAD_1, IMUL ])
	public infix func *(int v1, int v2): int = v1 * v2

	@Intrinsic([ LOAD_0, I2F, LOAD_1, I2F, FDIV ])
	public infix func /(int v1, int v2): float = v1 / v2

	@Intrinsic([ LOAD_0, LOAD_1, IREM ])
	public infix func %(int v1, int v2): int = v1 % v2

	@Intrinsic([ LOAD_0, LOAD_1, IDIV ])
	public infix func \(int v1, int v2): int = v1 \ v2

	@Intrinsic([ LOAD_0, LOAD_1, IAND ])
	public infix func &(int v1, int v2): int = v1 & v2

	@Intrinsic([ LOAD_0, LOAD_1, IOR ])
	public infix func |(int v1, int v2): int = v1 | v2

	@Intrinsic([ LOAD_0, LOAD_1, IXOR ])
	public infix func ^(int v1, int v2): int = v1 ^ v2

	@Intrinsic([ LOAD_0, LOAD_1, ISHL ])
	public infix func <<(int v1, int v2): int = v1 << v2

	@Intrinsic([ LOAD_0, LOAD_1, ISHR ])
	public infix func >>(int v1, int v2): int = v1 >> v2

	@Intrinsic([ LOAD_0, LOAD_1, IUSHR ])
	public infix func >>>(int v1, int v2): int = v1 >>> v2

	// Int Methods

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Integer", "toString", "(I)Ljava/lang/String;" ])
	public infix String toString(int value) = value.toString

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Integer", "toBinaryString", "(I)Ljava/lang/String;" ])
	public infix String toBinaryString(int value) = value.toBinaryString

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Integer", "toHexString", "(I)Ljava/lang/String;" ])
	public infix String toHexString(int value) = value.toHexString

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Integer", "toOctalString", "(I)Ljava/lang/String;" ])
	public infix String toOctalString(int value) = value.toOctalString

	public infix String toString(int value, int radix) =
		radix match {
			case 2: return value.toBinaryString
			case 8: return value.toOctalString
			case 10: return value.toString
			case 16: return value.toHexString
			case _ : return java.lang.Integer.toString(value, radix);
		}

	@Intrinsic([ LOAD_0, LOAD_1, ICMPEQ ])
	public infix boolean equals(int i1, int i2) = i1 == i2

	@Intrinsic([ LOAD_0 ])
	public infix int hashCode(int v) = v

	// Char Methods

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/String", "valueOf", "(C)Ljava/lang/String;" ])
	public infix String toString(char c) = String.valueOf(c)

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Integer", "toString", "(I)Ljava/lang/String;" ])
	public infix String toDecimalString(char c) = c.toDecimalString

	// Long Operators

	@Intrinsic([ LOAD_0 ])
	public prefix func +(long value): long = value

	@Intrinsic([ LOAD_0, LNEG ])
	public prefix func -(long value): long = -value

	@Intrinsic([ LOAD_0, LNOT ])
	public prefix func ~(long value): long = ~value

	@Intrinsic([ LOAD_0, LOAD_1, LCMPEQ ])
	public infix func ==(long v1, long v2): boolean = v1 == v2

	@Intrinsic([ LOAD_0, LOAD_1, LCMPNE ])
	public infix func !=(long v1, long v2): boolean = v1 != v2

	@Intrinsic([ LOAD_0, LOAD_1, LCMPLT ])
	public infix func <(long v1, long v2): boolean = v1 < v2

	@Intrinsic([ LOAD_0, LOAD_1, LCMPLE ])
	public infix func <=(long v1, long v2): boolean = v1 <= v2

	@Intrinsic([ LOAD_0, LOAD_1, LCMPGT ])
	public infix func >(long v1, long v2): boolean = v1 > v2

	@Intrinsic([ LOAD_0, LOAD_1, LCMPGE ])
	public infix func >=(long v1, long v2): boolean = v1 >= v2

	@Intrinsic([ LOAD_0, LOAD_1, LADD ])
	public infix func +(long v1, long v2): long = v1 + v2

	@Intrinsic([ LOAD_0, LOAD_1, LSUB ])
	public infix func -(long v1, long v2): long = v1 - v2

	@Intrinsic([ LOAD_0, LOAD_1, LMUL ])
	public infix func *(long v1, long v2): long = v1 * v2

	@Intrinsic([ LOAD_0, L2D, LOAD_1, L2D, DDIV ])
	public infix func /(long v1, long v2): double = v1 / v2

	@Intrinsic([ LOAD_0, LOAD_1, LREM ])
	public infix func %(long v1, long v2): long = v1 % v2

	@Intrinsic([ LOAD_0, LOAD_1, LDIV ])
	public infix func \(long v1, long v2): long = v1 \ v2

	@Intrinsic([ LOAD_0, LOAD_1, LAND ])
	public infix func &(long v1, long v2): long = v1 & v2

	@Intrinsic([ LOAD_0, LOAD_1, LOR ])
	public infix func |(long v1, long v2): long = v1 | v2

	@Intrinsic([ LOAD_0, LOAD_1, LXOR ])
	public infix func ^(long v1, long v2): long = v1 ^ v2

	@Intrinsic([ LOAD_0, LOAD_1, L2I, LSHL ])
	public infix func <<(long v1, long v2): long = v1 << v2

	@Intrinsic([ LOAD_0, LOAD_1, L2I, LSHR ])
	public infix func >>(long v1, long v2): long = v1 >> v2

	@Intrinsic([ LOAD_0, LOAD_1, L2I, LUSHR ])
	public infix func >>>(long v1, long v2): long = v1 >>> v2

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Long", "toString", "(J)Ljava/lang/String;" ])
	public infix String toString(long value) = value.toString

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Long", "toHexString", "(J)Ljava/lang/String;" ])
	public infix String toHexString(long value) = value.toHexString

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Long", "toBinaryString", "(J)Ljava/lang/String;" ])
	public infix String toBinaryString(long value) = value.toBinaryString

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Long", "toOctalString", "(J)Ljava/lang/String;" ])
	public infix String toOctalString(long value) = value.toOctalString

	public infix String toString(long value, int radix) =
		radix match {
			case 2: return value.toBinaryString
			case 8: return value.toOctalString
			case 10: return value.toString
			case 16: return value.toHexString
			case _ : return java.lang.Long.toString(value, radix);
		}

	@Intrinsic([ LOAD_0, LOAD_1, LCMPEQ ])
	public postfix boolean equals(long l1, long l2) = l1 == l2

	@Intrinsic([ LOAD_0, DUP2, BIPUSH, 32, LUSHR, LXOR, L2I ])
	public postfix int hashCode(long value) = value.hashCode

	// Float Operators

	@Intrinsic([ LOAD_0 ])
	public prefix func +(float value): float = value

	@Intrinsic([ LOAD_0, FNEG ])
	public prefix func -(float value): float = -value

	@Intrinsic([ LOAD_0, LOAD_1, FCMPEQ ])
	public infix func ==(float v1, float v2): boolean = v1 == v2

	@Intrinsic([ LOAD_0, LOAD_1, FCMPNE ])
	public infix func !=(float v1, float v2): boolean = v1 != v2

	@Intrinsic([ LOAD_0, LOAD_1, FCMPLT ])
	public infix func <(float v1, float v2): boolean = v1 < v2

	@Intrinsic([ LOAD_0, LOAD_1, FCMPLE ])
	public infix func <=(float v1, float v2): boolean = v1 <= v2

	@Intrinsic([ LOAD_0, LOAD_1, FCMPGT ])
	public infix func >(float v1, float v2): boolean = v1 > v2

	@Intrinsic([ LOAD_0, LOAD_1, FCMPGE ])
	public infix func >=(float v1, float v2): boolean = v1 >= v2

	@Intrinsic([ LOAD_0, LOAD_1, FADD ])
	public infix func +(float v1, float v2): float = v1 + v2

	@Intrinsic([ LOAD_0, LOAD_1, FSUB ])
	public infix func -(float v1, float v2): float = v1 - v2

	@Intrinsic([ LOAD_0, LOAD_1, FMUL ])
	public infix func *(float v1, float v2): float = v1 * v2

	@Intrinsic([ LOAD_0, LOAD_1, FDIV ])
	public infix func /(float v1, float v2): float = v1 / v2

	@Intrinsic([ LOAD_0, LOAD_1, FREM ])
	public infix func %(float v1, float v2): float = v1 % v2

	// Float Methods

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Float", "toString", "(F)Ljava/lang/String;" ])
	public postfix String toString(float value) = value.toString

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Float", "toHexString", "(F)Ljava/lang/String;" ])
	public postfix String toHexString(float value) = value.toHexString

	@Intrinsic([ LOAD_0, LOAD_1, FCMPEQ ])
    public infix boolean equals(float v1, float v2) = v1 == v2

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Float", "hashCode", "(F)I" ])
	public postfix int hashCode(float value) = value.hashCode

	// Double Operators

	@Intrinsic([ LOAD_0 ])
	public prefix func +(double value): double = value

	@Intrinsic([ LOAD_0, DNEG ])
	public prefix func -(double value): double = -value

	@Intrinsic([ LOAD_0, LOAD_1, DCMPEQ ])
	public infix func ==(double v1, double v2): boolean = v1 == v2

	@Intrinsic([ LOAD_0, LOAD_1, DCMPNE ])
	public infix func !=(double v1, double v2): boolean = v1 != v2

	@Intrinsic([ LOAD_0, LOAD_1, DCMPLT ])
	public infix func <(double v1, double v2): boolean = v1 < v2

	@Intrinsic([ LOAD_0, LOAD_1, DCMPLE ])
	public infix func <=(double v1, double v2): boolean = v1 <= v2

	@Intrinsic([ LOAD_0, LOAD_1, DCMPGT ])
	public infix func >(double v1, double v2): boolean = v1 > v2

	@Intrinsic([ LOAD_0, LOAD_1, DCMPGE ])
	public infix func >=(double v1, double v2): boolean = v1 >= v2

	@Intrinsic([ LOAD_0, LOAD_1, DADD ])
	public infix func +(double v1, double v2): double = v1 + v2

	@Intrinsic([ LOAD_0, LOAD_1, DSUB ])
	public infix func -(double v1, double v2): double = v1 - v2

	@Intrinsic([ LOAD_0, LOAD_1, DMUL ])
	public infix func *(double v1, double v2): double = v1 * v2

	@Intrinsic([ LOAD_0, LOAD_1, DDIV ])
	public infix func /(double v1, double v2): double = v1 / v2

	@Intrinsic([ LOAD_0, LOAD_1, DREM ])
	public infix func %(double v1, double v2): double = v1 % v2

	// Double Methods

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Double", "toString", "(D)Ljava/lang/String;" ])
	public postfix String toString(double value) = value.toString

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Double", "toHexString", "(D)Ljava/lang/String;" ])
	public postfix String toHexString(double value) = value.toHexString

	@Intrinsic([ LOAD_0, LOAD_1, DCMPEQ ])
	public infix boolean equals(double v1, double v2) = v1 == v2

	@Intrinsic(value: LOAD_CALL, strings: [ "java/lang/Double", "hashCode", "(D)I" ])
	public postfix int hashCode(double value) = value.hashCode
}
