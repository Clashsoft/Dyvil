package dyvil.lang

import dyvilx.lang.model.`type`.Type

import const dyvil.reflect.Opcodes._

public final class ObjectExtensions
{
	private init() { }

	// Class and Type conversions and utilities

	@Intrinsic([ LOAD_0 ])
	public static T cast<T>(any value) = value as T

	@Intrinsic([ LOAD_0 ])
	public static T convert<T>(T value) = value

	public static Class<T> classOf<@Reified(Reified.Type.ANY_CLASS) T>(T value) = class T

	public static Type<T> typeOf<@Reified(Reified.Type.TYPE) T>(T value) = type T

	// Useful globals

	public static inline R run<R>(-> R f) = f()

	public static infix inline R run<T, R>(T self, T.() -> R f) = f(self)

	public static infix inline T use<T>(T self, T.() -> void f) = self.{ f $0; $0 }

	public static inline R with<T, R>(T receiver, T -> R f) = f(receiver)

	// Object Extensions

	// Structural Equality (equals)
	@BytecodeName("$eq$eq_nonnull")
	@Intrinsic([ LOAD_0, LOAD_1, INVOKEVIRTUAL, 0, 1, 2 ]
	  strings: [ "java/lang/Object", "equals", "(Ljava/lang/Object;)Z" ])
	public infix func ==(Object lhs, Object! rhs): boolean = lhs.equals(rhs)

	public infix func ==(Object! lhs, Object! rhs): boolean = lhs == null ? rhs == null : lhs!!.equals(rhs)

	// Reference Equality
	@Intrinsic([ LOAD_0, LOAD_1, ACMPEQ ])
	public infix func ===(Object! lhs, Object! rhs): boolean = lhs === rhs

	// Structural Inequality (!equals)
	@BytecodeName("$bang$eq_nonnull")
	@Intrinsic([ LOAD_0, LOAD_1, INVOKEVIRTUAL, 0, 1, 2, BNOT ]
	  strings: [ "java/lang/Object", "equals", "(Ljava/lang/Object;)Z" ])
	public infix func !=(Object lhs, Object! rhs): boolean = !lhs.equals(rhs)

	@Intrinsic([ LOAD_0, LOAD_1, INVOKESTATIC, 0, 1, 2, BNOT ]
	  strings: [ "dyvil/lang/ObjectExtensions", "$eq$eq", "(Ljava/lang/Object;Ljava/lang/Object;)Z" ])
	public infix func !=(Object! lhs, Object! rhs): boolean = lhs != rhs

	// Reference Inequality
	@Intrinsic([ LOAD_0, LOAD_1, ACMPNE ])
	public infix func !==(Object! lhs, Object! rhs): boolean = lhs !== rhs

	// Optionals

	@Intrinsic([ LOAD_0 ])
	public static func Optional<T>(T value): T? = value

	/*
	 * The Optional Unwrap Operator
	 *
	 * Attempts to unwrap an optional value. If the given parameter has the value `null` at runtime, a
	 * `NullPointerException` is thrown.
	 */
	@Intrinsic([ LOAD_0, DUP, INVOKESTATIC, 0, 1, 2 ]
	  strings: [ "dyvil/lang/ObjectExtensions", "unwrapNullCheck", "(Ljava/lang/Object;)V" ])
	public postfix func ! <T>(T? optional): T = optional!

	/**
	 * Checks if the given optional value is null and throws a NullPointerException in that case.
	 */
	public static func unwrapNullCheck<T>(T? optional): void
	{
		if (optional == null) throw new NullPointerException("Unwrapped Optional was null")
	}

	/**
	 * The Unsafe Unwrap Operator
	 *
	 * Unwraps an optional value in an unsafe manner, i.e. without a null check. Use this only if you are sure that
	 * parameter is never actually null.
	 */
	@Intrinsic([ LOAD_0 ])
	public postfix func !! <T>(T? optional): T = optional!!

	/**
	 * The Nullable Coalescing Operator
	 *
	 * Returns the left-hand argument if it is not `null` at runtime, and the right-hand argument otherwise.
	 */
	public infix func ?? <T, U> (T? lhs, U rhs): T|U = lhs != null ? lhs!! : rhs

	// Comparable

	public infix inline func < <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) < 0

	public infix inline func <= <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) <= 0

	public infix inline func > <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) > 0

	public infix inline func >= <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) >= 0
}
