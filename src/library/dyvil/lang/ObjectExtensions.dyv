package dyvil.lang

import const dyvil.reflect.Opcodes._

public final class ObjectExtensions
{
	private init() { }

	// Class and Type conversions and utilities

	@Intrinsic([ LOAD_0 ])
	public static T cast<T>(any value) = value as T

	@Intrinsic([ LOAD_0 ])
	public static T convert<T>(T value) = value

	// Useful globals

	public static inline R run<R>(-> R f) = f()

	public static infix inline R run<T, R>(T self, T.() -> R f) = f(self)

	public static infix inline T use<T>(T self, T.() -> void f) { f self; self }

	public static inline R with<T, R>(T receiver, T -> R f) = f(receiver)

	// Object Extensions

	// Structural Equality (equals)

	@Intrinsic([ LOAD_0, LOAD_1, INVOKEVIRTUAL, 0, 1, 2 ]
	  strings: [ "java/lang/Object", "equals", "(Ljava/lang/Object;)Z" ])
	public infix func ==(Object lhs, Object! rhs): boolean = lhs.equals(rhs)

	@BytecodeName("equals")
	public infix func ==(Object! lhs, Object! rhs): boolean = lhs === rhs || lhs != null && lhs!!.equals(rhs)

	@OverloadPriority
	// @Deprecated(replacements: [ '===(Object!, null): boolean' ])
	@Intrinsic([ LOAD_0, IS_NULL ])
	public infix func ==(Object! lhs, null rhs): boolean = lhs == null

	@OverloadPriority
	// @Deprecated(replacements: [ '===(null, Object!): boolean' ])
	@Intrinsic([ LOAD_1, IS_NULL ])
	public infix func ==(null lhs, Object! rhs): boolean = rhs == null

	// Reference Equality

	@Intrinsic([ LOAD_0, LOAD_1, ACMPEQ ])
	public infix func ===(Object! lhs, Object! rhs): boolean = lhs === rhs

	@OverloadPriority
	@Intrinsic([ LOAD_0, IS_NULL ])
	public infix func ===(Object! lhs, null rhs): boolean = lhs === null

	@OverloadPriority
	@Intrinsic([ LOAD_1, IS_NULL ])
	public infix func ===(null lhs, Object! rhs): boolean = rhs === null

	// Structural Inequality (!equals)

	@Intrinsic([ LOAD_0, LOAD_1, INVOKEVIRTUAL, 0, 1, 2, BNOT ]
	  strings: [ "java/lang/Object", "equals", "(Ljava/lang/Object;)Z" ])
	public infix func !=(Object lhs, Object! rhs): boolean = !lhs.equals(rhs)

	@BytecodeName("notEquals")
	@Intrinsic([ LOAD_0, LOAD_1, INVOKESTATIC, 0, 1, 2, BNOT ]
	  strings: [ "dyvil/lang/ObjectExtensions", "$eq$eq", "(Ljava/lang/Object;Ljava/lang/Object;)Z" ])
	public infix func !=(Object! lhs, Object! rhs): boolean = lhs != rhs

	@OverloadPriority
	// @Deprecated(replacements: [ '!==(Object!, null): boolean' ])
	@Intrinsic([ LOAD_0, IS_NONNULL ])
	public infix func !=(Object! lhs, null rhs): boolean = lhs != null

	@OverloadPriority
	// @Deprecated(replacements: [ '!==(null, Object!): boolean' ])
	@Intrinsic([ LOAD_1, IS_NONNULL ])
	public infix func !=(null lhs, Object! rhs): boolean = rhs != null

	// Reference Inequality

	@Intrinsic([ LOAD_0, LOAD_1, ACMPNE ])
	public infix func !==(Object! lhs, Object! rhs): boolean = lhs !== rhs

	@OverloadPriority
	@Intrinsic([ LOAD_0, IS_NONNULL ])
	public infix func !==(Object! lhs, null rhs): boolean = lhs !== null

	@OverloadPriority
	@Intrinsic([ LOAD_1, IS_NONNULL ])
	public infix func !==(null lhs, Object! rhs): boolean = rhs !== null

	// Comparable

	public infix inline func < <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) < 0

	public infix inline func <= <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) <= 0

	public infix inline func > <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) > 0

	public infix inline func >= <T>(Comparable<T> lhs, T rhs): boolean = lhs.compareTo(rhs) >= 0
}
