package dyvil.lang

using dyvil.reflect.Opcodes._
using dyvil.reflect.ReflectUtils._
import dyvil.string.StringUtils

public final class StringExtensions
{
	private static final long STRING_VALUE_OFFSET = UNSAFE.objectFieldOffset(class<String>.getDeclaredField("value"))

	private init() {}

	// Concat Operators

	@Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT)
	infix func +(lhs: String, rhs: any!) -> String = lhs + rhs

	@Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT)
	infix func +(lhs: any!, rhs: String) -> String = lhs + rhs

	@Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT)
	infix func +(lhs: String, rhs: String) -> String = lhs + rhs

	// Makeshift char casts

	static inline func char(char c) -> char = c

	/**
	 * This method only exists to provide the user with a useful warning message when trying to pass an invalid char
	 * literal to the `char` method. An invalid char literal would be a double-quoted String or a single-quoted String
	 * with zero or more than one character to the `char` method.
	 */
	@UsageInfo(value: "Multi-character Literal or String passed to 'char' method", level: dyvil.util.MarkerLevel.WARNING)
	static inline func char(String c) -> char = c.charAt 0

	// Unsafe access

	static func String([final char] fromShared) -> String
	{
		return JAVA_LANG_ACCESS.newStringUnsafe(fromShared)
	}

	static postfix func getCharArray(String s) -> [final char]
	{
		return UNSAFE.getObject(s, STRING_VALUE_OFFSET) as [final char]
	}

	// Subscripts

	infix inline func subscript(String s, int index) -> char = s.charAt index

	infix inline func subscript(String s, Range<int> range) -> String = s.substring(range.first, range.last)

	// Repetition (*) Operator

	infix inline func *(int n, String s) -> String = StringUtils.repeated(s, n)

	infix inline func *(String s, int n) -> String = StringUtils.repeated(s, n)

	// Misc. additional extensions

	infix inline func contains(String s, char character) -> boolean = StringUtils.contains(s, character)

	infix inline func split(String s, char delimiter) -> [String] = StringUtils.split(s, delimiter) as [String]

	infix inline func format(String s, Object! ... args) -> String = String.format(s, args...)

	extension func toString(Object o, StringBuilder builder) -> void = builder.append o
}
