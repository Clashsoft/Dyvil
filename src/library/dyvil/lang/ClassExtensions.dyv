package dyvil.lang

import const dyvil.reflect.Opcodes._
import const dyvil.annotation.Reified.Type._

public abstract class ClassExtensions
{
	private init()
	{
		// no instances
	}

	// Value to Type / Class Conversions

	postfix func staticClass<@Reified(ANY_CLASS) type T: Object>(value: T) -> Class<T> = class T

	postfix func staticType<@Reified(TYPE) type T: Object>(value: T) -> Type<T> = type T

	@Intrinsic([ LOAD_0, INVOKEVIRTUAL, 0, 1, 2 ]
	  strings: [ "java/lang/Object", "getClass", "()Ljava/lang/Class;" ])
	postfix func dynamicClass<type T: Object>(value: T) -> Class<+T> = value.getClass as Class<+T>

	// Class Extensions

	static func arrayType<@Reified(OBJECT_CLASS) type T: any>() -> Class<[T]> = arrayType<T>(class T)

	@BytecodeName("arrayTypeOf")
	postfix func arrayType<type T: any>(componentType: Class<T>) -> Class<_>
	{
		let builder = new StringBuilder().append '['

		if (componentType.isPrimitive)
		{
			dyvil.reflect.types.PrimitiveType(componentType).appendSignature(builder)
		}
		else if (componentType.isArray)
		{
			builder.append(componentType.getName)
		}
		else
		{
			builder.append('L').append(componentType.getName).append(';')
		}

		return Class.forName(builder.toString, false, componentType.getClassLoader)
	}
}
