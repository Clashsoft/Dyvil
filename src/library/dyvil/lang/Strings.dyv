package dyvil.lang

import java.util.regex.{ Pattern, Matcher }

@JavaName("Strings")
extension String
{
	private const STRING_VALUE_OFFSET: long = dyvil.reflect.ReflectUtils.UNSAFE.objectFieldOffset(class<String>.getDeclaredField("value"))

	// =============== Static Methods ===============

	static func build(with closure: StringBuilder -> void) -> String inline = new StringBuilder().use(closure).toString!!

	static func build(withCapacity capacity: int, closure: StringBuilder -> void) -> String inline = new StringBuilder(capacity).use(closure).toString!!

	static func fromShared(array: [final char]) -> String = dyvil.reflect.ReflectUtils.JAVA_LANG_ACCESS.newStringUnsafe(array)!!

	// =============== Methods ===============

	func getCharArray() -> [final char] = dyvil.reflect.ReflectUtils.UNSAFE.getObject(this, STRING_VALUE_OFFSET) as [final char]

	func contains(character: char) -> boolean inline = this.indexOf(character) >= 0

	func count(character: char) -> int
	{
		var count = 0
		for (c <- this) if (c == character) count += 1
		return count
	}

	func split(by delimiter: char) -> [String]
	{
		let count = this.count(delimiter)
		if (count == 0) return [this]

		let array = new [String](count + 1)
		var start = 0
		var arrayIndex = 0

		for (i <- 0 ..< this.length)
		{
			if (this[i] == delimiter)
			{
				array[arrayIndex] = this.substring(start, i)!!
				arrayIndex += 1
				start = i + 1
			}
		}
		array[arrayIndex] = this.substring(start)!!
		return array
	}

	func format(args: Object! ...) -> String inline = String.format(this, args...)!!

	func distance(to that: String) -> int
	{
		if (this == that) return 0

		let size1 = this.length
		let size2 = that.length

		if (size1 == 0) return size2
		if (size2 == 0) return size1

		let arraySize = size2 + 1
		let array1 = new [int](arraySize)
		let array2 = new [int](arraySize)

		for (i <- 0 ..< arraySize) array1[i] = i
		for (i <- 0 ..< size1)
		{
			array2[0] = i + 1
			for (j <- 0 ..< size2)
			{
				let offset = (this[i] != that[j]) ? 1 : 0
				array2[j + 1] = Math.min(array2[j] + 1, Math.min(array1[j + 1] + 1, array1[j] + offset))
			}
			System.arraycopy(array2, 0, array1, 0, arraySize)
		}
		return array2[size2]
	}

	func replaceAll(regex: String, by replacer: String -> String) -> String inline = this.replaceAll(Pattern(from: regex), replacer)

	func replaceAll(pattern: Pattern, by replacer: String -> String) -> String
	{
		let matcher = pattern.matcher(this)!!
		let buffer = new StringBuffer

		while (matcher.find())
		{
			matcher.appendReplacement(buffer, replacer(matcher.group()!!))
		}

		matcher.appendTail(buffer)
		return buffer.toString!!
	}

	@JavaName("repeat")
	func repeated(times: int) -> String = times match {
		case 0 => return ""
		case 1 => return this
		case 2 => return this.concat(this)!!
		case _ => build(this.length * times) { for (i <- 0 ..< times) $0.append(this) }
	}
}

// The following classes only have syntactic meaning in the Dyvil language,
// they are practically useless in Java code.

@JavaName("Strings$StringSyntax")
extension String
{
	// =============== Static Methods ===============

	// --------------- apply ---------------

	static func apply(from value: any!) -> String inline = "\(value)"

	static func apply(from sequence: CharSequence) implicit -> String inline = "\(sequence)"

	static func apply(fromShared array: [final char]) -> String inline = String.fromShared(array)

	// =============== Methods ===============

	func size() -> int inline = this.length

	func subscript(index: int) -> char inline = this.charAt(index)

	func subscript(range: Range<int>) -> String inline = this.substring(range.first, range.last + 1)!!

	// =============== Operators ===============

	// --------------- Concatenation ---------------

	infix func +(lhs: char, rhs: String) -> String @Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT) = lhs + rhs

	infix func +(lhs: String, rhs: char) -> String @Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT) = lhs + rhs

	infix func ++(lhs: String, rhs: String) -> String @Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT) = lhs ++ rhs

	// --------------- Repetition ---------------

	infix func *(lhs: int, rhs: String) -> String inline = rhs.repeated(lhs)

	infix func *(lhs: String, rhs: int) -> String inline = lhs.repeated(rhs)

	// --------------- Length ---------------

	static func |_|(string: CharSequence) -> int inline = string.length
}

@JavaName("Strings$CharSequenceSyntax")
extension CharSequence
{
	// =============== Methods ===============

	func subscript(index: int) -> char inline = this.charAt(index)

	func subscript(range: Range<int>) -> CharSequence inline = this.subSequence(range.first, range.last + 1)
}

@JavaName("Strings$CharSyntax")
extension char
{
	// =============== Static Methods ===============

	// --------------- char ---------------

	static func char(_ c: char) -> char inline = c

	/**
	 * This method only exists to provide the user with a useful warning message when trying to pass an invalid char
	 * literal to the `char` method. An invalid char literal would be a double-quoted String or a single-quoted String
	 * with zero or more than one characters.
	 */
	@UsageInfo(value: "Multi-character Literal or String passed to 'char' method", level: .WARNING)
	static func char(_ c: String) -> char inline = c[0]
}

@JavaName("Strings$PatternSyntax")
extension Pattern
{
	// =============== Methods ===============

	static func apply(from string: String) implicit -> Pattern inline = Pattern.compile(string)!!
}

@JavaName("Strings$AnyToStringBuilder")
extension any
{
	// =============== Methods ===============

	func toString(builder: StringBuilder) -> void inline = builder.append(this)
}
