package dyvil.lang

using dyvil.math.MathUtils._
using dyvil.reflect.Opcodes._
using dyvil.reflect.ReflectUtils._

import java.util.regex.{ Pattern, Matcher }

abstract class Strings
{
	private const STRING_VALUE_OFFSET: long = UNSAFE.objectFieldOffset(class<String>.getDeclaredField("value"))

	private init() {}

	// Concat Operators

	@Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT)
	infix func +(lhs: char, rhs: String) -> String = lhs + rhs

	@Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT)
	infix func +(lhs: String, rhs: char) -> String = lhs + rhs

	@Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT)
	infix func ++(lhs: String, rhs: String) -> String = lhs ++ rhs

	// Creation

	inline static func char(c: char) -> char = c

	/**
	 * This method only exists to provide the user with a useful warning message when trying to pass an invalid char
	 * literal to the `char` method. An invalid char literal would be a double-quoted String or a single-quoted String
	 * with zero or more than one characters.
	 */
	@UsageInfo(value: "Multi-character Literal or String passed to 'char' method", level: .WARNING)
	inline static func char(c: String) -> char = c[0]

	static func apply(this: String, from: any!) -> String = "\(from)"

	implicit static func apply(this: String, from: CharSequence) -> String = "\(from)"

	@BytecodeName("fromShared")
	static func apply(this: String, fromShared: [final char]) -> String = JAVA_LANG_ACCESS.newStringUnsafe(fromShared)

	// Subscripts

	inline infix func subscript(s: CharSequence, index: int) -> char = s.charAt index

	inline infix func subscript(s: CharSequence, range: Range<int>) -> CharSequence = s.subSequence(range.first, range.last + 1)

	inline infix func subscript(s: String, range: Range<int>) -> String = s.substring(range.first, range.last + 1)

	postfix func getCharArray(s: String) -> [final char] = UNSAFE.getObject(s, STRING_VALUE_OFFSET) as [final char]

	// Repetition (*) Operator

	infix func *(lhs: int, rhs: String) -> String = repeated(rhs, lhs)

	infix func *(lhs: String, rhs: int) -> String = repeated(lhs, rhs)

	private static func repeated(string: String, times: int) -> String = times match {
		case 0 => return ""
		case 1 => return string
		case 2 => return string.concat(string)
		case _ => new StringBuilder().{ for (i <- 0 ..< times) append(string); $0.toString }
	}

	// Misc. additional extensions

	inline infix func size(string: CharSequence) -> int = string.length

	inline infix func contains(s: String, character: char) -> boolean = s.indexOf(character) >= 0

	infix func count(string: String, character: char) -> int
	{
		var count = 0
		for (c <- string) if (c == character) count += 1
		return count
	}

	infix func split(string: String, by delimiter: char) -> [String]
	{
		let count = string.count(delimiter)
		if (count == 0) return [string]

		let array = new [String](count + 1)
		var start = 0
		var arrayIndex = 0

		for (i <- 0 ..< string.length)
		{
			if (string[i] == delimiter)
			{
				array[arrayIndex] = string.substring(start, i)
				arrayIndex += 1
				start = i + 1
			}
		}
		array[arrayIndex] = string.substring(start)
		return array
	}

	inline infix func format(s: String, args: Object! ...) -> String = String.format(s, args...)

	infix func distance(string: String, to: String) -> int
	{
		if (string == to) return 0

		let size1 = string.length
		let size2 = to.length

		if (size1 == 0) return size2
		if (size2 == 0) return size1

		let arraySize = size2 + 1
		let array1 = new [int](arraySize)
		let array2 = new [int](arraySize)

		for (i <- 0 ..< arraySize) array1[i] = i
		for (i <- 0 ..< size1)
		{
			array2[0] = i + 1
			for (j <- 0 ..< size2)
			{
				let offset = (string[i] != to[j]) ? 1 : 0
				array2[j + 1] = min(array2[j] + 1, array1[j + 1] + 1, array1[j] + offset)
			}
			System.arraycopy(array2, 0, array1, 0, arraySize)
		}
		return array2[size2]
	}

	infix func replaceAll(string: String, target: String, by replacer: String -> String)
	{
		let p: Pattern = Pattern.compile(target)
		let m: Matcher = p.matcher(string)
		let buffer = new StringBuffer

		while (m.find())
		{
			m.appendReplacement(buffer, replacer(m.group()))
		}

		m.appendTail(buffer)
		return buffer.toString!!
	}

	extension func toString(o: any, builder: StringBuilder) -> void = builder.append o
}
