package dyvil.lang

import dyvil.collection.range.specialized.IntRange
import java.util.regex.{ Pattern, Matcher }

@JavaName("Strings")
extension String {
	// =============== Operators ===============

	// --------------- Pattern Matching ---------------

	// here so the compiler does not use the Pattern-based method with an implicit conversion
	infix func ~=(pattern: String, value: String) = pattern == value

	infix func ~=(pattern: Pattern, value: String) = pattern.matches(value)

	// --------------- Concatenation ---------------

	infix func +(lhs: char, rhs: String) -> String @Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT) = lhs + rhs

	infix func +(lhs: String, rhs: char) -> String @Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT) = lhs + rhs

	infix func ++(lhs: String, rhs: String) -> String @Intrinsic([], compilerCode: Intrinsic.STRING_CONCAT) = lhs ++ rhs

	// --------------- Repetition ---------------

	infix func *(lhs: int, rhs: String) -> String inline = rhs.repeated(lhs)

	infix func *(lhs: String, rhs: int) -> String inline = lhs.repeated(rhs)

	// =============== Static Methods ===============

	static func apply(from value: any!) -> String inline = "\(value)"

	static func apply(from sequence: CharSequence) implicit -> String inline = sequence.toString()

	@JavaName("build")
	static func apply(builtBy closure: StringBuilder.() -> void) -> String inline
		= new StringBuilder().use(closure).toString!!

	@JavaName("build")
	static func apply(capacity: int, builtBy closure: StringBuilder.() -> void) -> String inline
		= new StringBuilder(capacity).use(closure).toString!!

	@JavaName("fromShared")
	static func apply(sharing array: [final char]) -> String
		= dyvil.reflect.ReflectUtils.JAVA_LANG_ACCESS.newStringUnsafe(array)!!

	// =============== Methods ===============

	@Deprecated(description: "use String.charCount", since: "0.45.0", forRemoval: "v0.46.0",
	            replacements: [ "String.charCount" ])
	@java.lang.Deprecated // use String.length
	final func size() -> int inline = this.length

	// --------------- Char Access ---------------

	final func subscript(index: int) -> char inline = this.charAt(index)

	final func subscript(range: Range<int>) -> String inline = this.substring(range.first, range.last + 1)!!

	@JavaName("getCharArray")
	@java.lang.Deprecated // moved to UnsafeStrings
	final func __getCharArray() -> [final char] = this.getCharArray()

	@JavaName("contains")
	@java.lang.Deprecated // moved to StringChars
	final func __contains(character: char) -> boolean = this.contains(character)

	@JavaName("count")
	@java.lang.Deprecated // moved to StringChars
	final func __count(character: char) -> int = this.count(character)

	@JavaName("split")
	@java.lang.Deprecated // moved to StringChars
	final func __split(by delimiter: char) -> [String] = this.split(by: delimiter)

	// --------------- Misc. ---------------

	final func format(args: Object! ...) -> String inline = String.format(this, args...)!!

	final func distance(to that: String) -> int {
		if this == that {
			return 0
		}

		let size1 = this.length
		let size2 = that.length

		if size1 == 0 {
			return size2
		}
		if size2 == 0 {
			return size1
		}

		let arraySize = size2 + 1
		let array1 = new [int](arraySize)
		let array2 = new [int](arraySize)

		for i <- 0 ..< arraySize {
			array1[i] = i
		}
		for i <- 0 ..< size1 {
			array2[0] = i + 1
			for j <- 0 ..< size2 {
				let offset = (this[i] != that[j]) ? 1 : 0
				array2[j + 1] = Math.min(array2[j] + 1, Math.min(array1[j + 1] + 1, array1[j] + offset))
			}
			System.arraycopy(array2, 0, array1, 0, arraySize)
		}
		return array2[size2]
	}

	final func replaceAll(regex: String, by replacer: String -> String) -> String inline
		= this.replaceAll(Pattern(from: regex), replacer)

	final func replaceAll(pattern: Pattern, by replacer: String -> String) -> String {
		let matcher = pattern.matcher(this)!!
		let buffer = new StringBuffer

		while matcher.find() {
			matcher.appendReplacement(buffer, replacer(matcher.group()!!))
		}

		matcher.appendTail(buffer)
		return buffer.toString!!
	}

	@JavaName("repeat")
	final func repeated(times: int) -> String = times match {
		case 0 => return ""
		case 1 => return this
		case 2 => return this.concat(this)!!
		case _ => String(this.length * times) { for i <- 0 ..< times { $0.append(this) } }
	}
}

@JavaName("UnsafeString")
extension String {
	// =============== Constants ===============

	private const STRING_VALUE_OFFSET: long
		= dyvil.reflect.ReflectUtils.UNSAFE.objectFieldOffset(class<String>.getDeclaredField("value"))

	// =============== Static Methods ===============

	@JavaName("fromShared")
	static func apply(sharing array: [final char]) -> String
		= dyvil.reflect.ReflectUtils.JAVA_LANG_ACCESS.newStringUnsafe(array)!!

	// =============== Methods ===============

	final func getCharArray() -> [final char]
		= dyvil.reflect.ReflectUtils.UNSAFE.getObject(this, STRING_VALUE_OFFSET) as [final char]
}

@JavaName("StringChars")
extension String {
	// =============== Methods ===============

	final func charCount() -> int inline = this.length

	final func contains(character: char) -> boolean inline = this.indexOf(character) >= 0

	final func count(character: char) -> int {
		var count = 0
		for c <- this {
			if c == character {
				count += 1
			}
		}
		return count
	}

	final func split(by delimiter: char) -> [String] {
		let count = this.count(delimiter)
		if count == 0 {
			return [this]
		}

		let array = new [String](count + 1)
		var start = 0
		var arrayIndex = 0

		for i <- 0 ..< this.length {
			if this[i] == delimiter {
				array[arrayIndex] = this.substring(start, i)!!
				arrayIndex += 1
				start = i + 1
			}
		}
		array[arrayIndex] = this.substring(start)!!
		return array
	}
}

@JavaName("StringCodePoints")
extension String {
	// =============== Methods ===============

	final func codePointCount() -> int inline = this.codePointCount(0, this.length)

	final func contains(codePoint: int) -> boolean inline = this.indexOf(codePoint) >= 0

	final func count(codePoint: int) -> int {
		var count = 0
		var i = 0
		let len = this.length
		while i < len {
			let code = this.codePointAt(i)
			if code == codePoint {
				count += 1
			}
			i += Character.charCount(code)
		}
		return count
	}

	final func split(by delimiter: int) -> [String] {
		let count = this.count(delimiter)
		if count == 0 {
			return [this]
		}

		let array = new [String](count + 1)
		var start = 0
		var arrayIndex = 0
		var i = 0
		let len = this.length

		while i < len {
			let code = this.codePointAt(i)
			if code == delimiter {
				array[arrayIndex] = this.substring(start, i)!!
				arrayIndex += 1
				start = i += Character.charCount(code)
			}
		}
		array[arrayIndex] = this.substring(start)!!
		return array
	}
}

@JavaName("CharSequences")
extension CharSequence {
	// =============== Operators ===============

	static func |_|(_ s: CharSequence) -> int inline = s.length

	// =============== Methods ===============

	final func first() -> char inline = this.charAt(0)

	final func last() -> char inline = this.charAt(this.length - 1)

	final func indices() -> IntRange inline = 0 ..< this.length

	final func subscript(index: int) -> char inline = this.charAt(index)

	final func subscript(range: Range<int>) -> CharSequence inline = this.subSequence(range.first, range.last + 1)
}

@JavaName("Strings$CharSyntax")
extension char {
	// =============== Static Methods ===============

	static func apply(_ c: char) -> char inline = c

	/**
	 * This method only exists to provide the user with a useful warning message when trying to pass an invalid char
	 * literal to the `char` method. An invalid char literal would be a double-quoted String or a single-quoted String
	 * with zero or more than one characters.
	 */
	@UsageInfo(value: "Multi-character Literal or String passed to 'char' method", level: .WARNING)
	static func apply(_ c: String) -> char inline = c[0]
}

@JavaName("Patterns")
extension Pattern {
	// =============== Methods ===============

	static func apply(from string: String) implicit -> Pattern inline = Pattern.compile(string)!!

	final func matches(string: String) -> boolean = this.matcher(string).matches()
}

@JavaName("Strings$AnyToStringBuilder")
extension any {
	// =============== Methods ===============

	func toString(builder: StringBuilder) -> void inline = builder.append(this)
}
