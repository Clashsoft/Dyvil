# suppress inspection "UnusedProperty" for whole file

# Members and Names

member.named=%1$s '%2$s'

member.header=header
member.typealias=type alias

member.class=class
member.interface=interface
member.trait=trait
member.annotation=annotation class
member.enum=enum class
member.object=object class

member.method=method
member.constructor=constructor
member.initializer=initializer
member.field=field
member.property=property
member.property.setter=property setter
member.property.getter=property getter

member.parameter=parameter
member.classparameter=class parameter
member.variable=variable
member.typeparameter=type parameter

# Resolution

resolve.any='%s' could not be resolved to a type, method or field
resolve.package='%s' could not be resolved to a package or class
resolve.header='%s' could not be resolved to a header file
resolve.type='%s' could not be resolved to a type
resolve.type.package='%1$s' could not be resolved to a type in '%2$s'
resolve.field='%s' could not be resolved to a field
resolve.label='%s' could not be resolved to a label

# Headers

package_declaration.missing=Missing package declaration in non-default package '%s'
package_declaration.mismatch=Package declaration '%s' does not match enclosing package '%s'
package_declaration.default_package=Package declaration '%s' is not allowed in default package

import.invalid=Invalid Import Declaration
import.resolve='%s' could not be resolved
import.inline_header.internal=The internal header '%s' cannot be included because it is private to it's library
import.inline_header.invisible=The header '%s' cannot be included because it is not visible

header.name.mismatch=Invalid Header Declaration - Mismatching Names
header.name=Header Name: %s
header.declaration.name=Header Declaration Name: %s

typealias.invalid=Invalid Type Alias - Type expected

# Type Parameters

type_parameter.bound.class=Type Parameters can only have one bound that is a class
type_parameter.declaration=Type Parameter: %s

# Types

type.access.invisible=The type '%s' cannot be accessed because it is not visible
type.access.internal=The internal class '%s' cannot be accessed because it is private to it's library
type.access.invalid=The instance of the type '%s' cannot be accessed because it is not an object type

type.annotated.invalid=Invalid Annotated Type - Type expected
type.wildcard.invalid=Wildcard Types cannot be used at this location

type.array.void=Array Types cannot wrap the type 'void'
type.array.super=Array Types cannot be used as super types

type.lambda.class=Lambda Types cannot be used at this location
type.lambda.return=Invalid Lambda Type - Missing Return Type

type.var.super=The Type Variable '%s' cannot be used as a super type
type.var.class=The un-reified Type Parameter '%s' cannot be used where a class type is expected
type.var.covariant=The covariant Type Parameter '%s' cannot be used in contravariant position
type.var.contravariant=The contravariant Type Parameter '%s' cannot be used in covariant position

type.alias.unresolved=The referenced type alias '%s' did not resolve correctly

type.dimensions=Type Dimensions: %d
type.expected=Expected Type: %s
type.enclosing=Enclosing Type: %s

## Generic Types

type.generic.class=Generic Types cannot be used at this location
type.generic.package.not_generic=The package '%s' cannot be parameterized
type.generic.class.not_generic=The non-generic class '%s' cannot be parameterized
type.generic.class.count_mismatch=Mismatching number of generic type arguments and type parameters of class '%s'
type.generic.type_parameter.not_generic=The type parameter '%s' cannot be parameterized
type.generic.type_alias.count_mismatch=Mismatching number of generic type arguments and type parameters of type alias '%s'

type.generic.count=Invalid number of generic type arguments
type.generic.incompatible=The generic type argument is incompatible with the type variable '%1$s' (in class %2$s)

type.generic.argument=Generic Type Argument: %s
type.generic.parameter_count=Type Parameter Count: %d
type.generic.argument_count=Type Argument Count: %d

# Annotations

annotation.type=The type '%s' is not an annotation type
annotation.type.invalid=Invalid Annotation - Missing Annotation Type
annotation.target=The annotation type '%s' is not applicable for the target
annotation.target.element=Element Target Type: %s
annotation.target.allowed=Allowed Target Types: %s
annotation.method='%2$s' could not be resolved to an annotation interface method for '%1$s'
annotation.constant=The value for '%s' has to be a constant expression
annotation.parameter.missing=The annotation of type '%1$s' does not provide a value for the non-default parameter '%2$s'
annotation.parameter.type=The value for '%s' is incompatible with the required type
annotation.array.not_constant=The array element cannot be converted to a compile-time constant
annotation.field.not_constant=The field '%1$s' cannot be folded to a compile-time constant

# -- Classes --

class.extend.type=The %1$s '%2$s' cannot be extended, only classes are allowed
class.extend.final=The final class '%s' cannot be extended
class.extend.internal=The internal class '%s' cannot be extended
class.implement.type=The %1$s '%2$s' cannot be implemented, only interfaces are allowed
class.implement.internal=The internal interface '%s' cannot be extended
class.object.constructor=The object class '%s' cannot have a constructor
class.method.abstract=The type '%1$s' doesn't override the abstract method '%2$s' of the super type '%3$s'
class.method.conflict=Conflicting interface method '%1$s' in direct super-interfaces of class '%2$s', override this method
class.inner.not_static=The inner class '%1$s' should use the 'static' modifier

class.descriptor.duplicate=The class '%s' does not have a unique descriptor '%s'
class.descriptor.duplicate.nested=The class '%1$s' does not have a unique descriptor '%3$s' in the enclosing class '%2$s'
class.descriptor.duplicate.header=The class '%1$s' does not have a unique descriptor '%3$s' in the enclosing header '%2$s'
class.descriptor.duplicate.package=The class '%1$s' does not have a unique descriptor '%3$s' in the enclosing package '%2$s'
class.descriptor.duplicate.external=The class '%1$s' has the descriptor '%3$s' which already exists in a library

class.object.field=The object class '%s' cannot declare a field named 'instance'

trait.field.warning=The field '%s' is implicitly public, static and final in a trait

interface.property.initializer=Properties in Interfaces cannot declare Property Initializers
interface.classparameters=Interfaces and Traits cannot declare Class Parameters
interface.constructor=Interfaces and Traits cannot declare Constructors
interface.initializer=Interfaces cannot declare Initializers

interface.functional.not_found=The functional interface '%s' does not have an abstract method
interface.functional.multiple=The functional interface '%s' has multiple abstract methods
interface.functional.class=The FunctionalInterface annotation can only be applied to interfaces and traits

enum.super_class=Enums must not have super types, only interfaces can be inherited from

extension.generic=Invalid extension class - extension classes cannot be generic
extension.field.invalid=Invalid field - extension classes can only contain 'private const' fields
extension.property.invalid=Invalid property - extension classes cannot contain properties

# Class Parameters

classparameter.type=Class Parameter Type: %s
classparameter.type.incompatible=The default value of the class parameter '%s' is incompatible with the parameter type
classparameter.type.infer=The type of the class parameter '%s' could not be inferred
classparameter.type.void=Class Parameters cannot have the type void

classparameter.override.not_found=The class parameter '%s' does not override a field from a super-class
classparameter.override.static=The class parameter '%1$s' overrides the static field '%1$s' from class '%2$s'
classparameter.override.property=The class parameter '%1$s' marked as 'override' must not have an associated property

classparameter.access.instance=The class parameter '%s' cannot be accessed from a static context
classparameter.access.unqualified=The class parameter '%s' should be qualified with 'this'
classparameter.assign.final=The final class parameter '%s' cannot be assigned
classparameter.assign.type=The type of the assigned value is incompatible with the type of the class parameter '%s'
classparameter.assign.annotation=The annotation parameter '%s' cannot be assigned

# -- Members --

# Modifiers

modifiers.visibility.default=The %1$s does not need to explicitly declare default visibility '%2$s'
modifiers.illegal=The %1$s has illegal modifiers: %2$s
modifiers.native.implemented=The %1$s cannot be declared native if it has an implementation
modifiers.native.abstract=The %1$s cannot be declared both native and abstract
modifiers.abstract.implemented=The %1$s cannot be declared abstract if it has an implementation
modifiers.abstract.concrete_class=The %1$s cannot be declared abstract as a member of the concrete type %2$s
modifiers.unimplemented=The %1$s is not implemented, but does not have an abstract modifier

# Access

access.invisible=The %2$s %1$s cannot be accessed because it is not visible
access.internal=The internal %s cannot be accessed because it is private to it's library

# Initializers

initializer.type=The block of an Initializer has to be usable as a statement

# Constructors

constructor.abstract=The constructor does not have an implementation
constructor.static=Constructors cannot be declared static
constructor.typevar.infer=The type argument for the type variable '%2$s' of the class '%1$s' was inferred to %3$s
constructor.typevar.incompatible=The type argument for the type variable '%2$s' of the class '%1$s' is incompatible with \
it's bounds

constructor.access.type.missing=Invalid Constructor - Missing Type
constructor.access.resolve=The constructor for '%s' could not be resolved
constructor.access.ambiguous=Ambiguous call to constructor of class '%s'
constructor.access.abstract=The abstract class '%s' cannot be instantiated
constructor.access.interface=The interface '%s' cannot be instantiated
constructor.access.internal=The internal constructor for '%s' cannot be accessed because it is private to it's library
constructor.access.array.length=The number of array length parameters exceeds the type dimensions
constructor.access.array.count=Number of Length Parameters: %d
constructor.access.array.type=The array length parameter has to be of type int
constructor.access.array.typevar=Cannot create an array of the generic type parameter %s

# -- Methods --

method.duplicate.descriptor=Duplicate method '%s' with descriptor '%s%s'
method.type=Method Return Type: %s
method.type.incompatible=The return value of the method '%s' is incompatible with the return type
method.type.infer=The type of the method '%s' could not be inferred
method.type.abstract=The type of the abstract method '%s' could not be inferred
method.exception.type=The thrown exception must be a subtype of java.lang.Throwable

method.this_type.incompatible=The receiver type of the method '%s' is incompatible with the enclosing class
method.this_type=Explicit 'this' Type: %s
method.enclosing_class=Enclosing Class Type: %s

# - Override Checks -
method.override.notfound=The method '%s' must override or implement a supertype method
method.overrides=The method '%s' overrides a method, but does not have an 'override' modifier

# Override Visibility
method.visibility=Method Visibility: %s
method.override.final=The method '%s' cannot override a final method
method.override.private=The method '%s' cannot override a private method
method.override.visibility=Overridden Method Visibility: %s
method.override.visibility.mismatch=The method '%s' cannot reduce the visibility of the overridden method

# Override Type
method.override=Overriden Method: %s (in %s)
method.override.parameter_label=The parameter label '%2$s' differs from the overridden methods label '%3$s' for parameter #%1$d
method.override.mangled_mismatch=The method '%1$s' does not override the method '%1$s' because the latter uses a \
  different, custom bytecode name '%2$s'
method.override.mangled_mismatch.info=Add '@BytecodeName('%1$s')' to use the same bytecode name
method.override.mangled_clash=The method '%1$s' does not override the method '%2$s', but uses the same bytecode name '%3$s'
method.override.mangled_clash.info=Add '@AutoMangled' or '@BytecodeName(custom name)' to use a different bytecode name
method.override.type=Overriden Return Type: %s
method.override.type.incompatible=The return type of the method '%s' is incompatible with the overridden method type

method.typevar.infer=The type argument for the type variable '%2$s' of the method '%1$s' was inferred to %3$s
method.typevar.incompatible=The type argument for the type variable '%2$s' of the method '%1$s' is incompatible with \
  it's bounds

method.access.static=The static method '%s' must be accessed in a static way
method.access.static.type=The static method '%1$s' of type '%2$s' should be accessed from that type
method.access.instance=The instance method '%s' cannot be accessed from a static context
method.access.unqualified=The instance method '%s' should be qualified with 'this'
method.access.infix_type=The infix method argument for '%s' is incompatible with the required type
method.access.receiver_type=The receiver for the instance method '%s' is incompatible with the required receiver type
method.access.prefix_type=The prefix method argument for '%s' is incompatible with the required type
method.access.argument_type=The method argument for '%s' is incompatible with the required type
method.access.argument.missing=Missing argument for parameter '%1$s'
method.access.argument.implicit=Missing implicit value for parameter '%1$s' of type '%2$s'
method.access.argument.empty=Missing argument for parameter '%s' cannot be inferred without explicit argument list
method.access.argument.empty.info=Add the empty argument list () at the end of the method call to fix
method.access.resolve='%s' could not be resolved to a method
method.access.resolve.field='%s' could not be resolved to a method or field
method.access.ambiguous=Ambiguous call to method '%s'
method.access.unresolved_type=The type of the method '%s' is unresolved

method.access.argument_types=Argument Types: %s
method.access.candidates=Candidates:

method.nested.access.early=The nested method '%s' cannot be used before it is declared

method.extension.this_type.invalid=The extension method '%s' must define a this type - add 'this: SomeType' as the first parameter

# Parameters

parameter.type=Parameter Type: %s
parameter.type.incompatible=The default value of the parameter '%s' is incompatible with the parameter type
parameter.type.infer=The type of the parameter '%s' could not be inferred
parameter.type.void=Parameters cannot have the type void
parameter.varargs.incompatible=The type of the varargs parameter '%s' is not convertible from an Array Expression

parameter.assign.final=The final parameter '%s' cannot be assigned
parameter.assign.type=The type of the assigned value is incompatible with the type of the parameter '%s'

arguments.duplicate.label=Duplicate Parameter Label '%s'

# Properties

property.initializer.type=The initializer of a Property has to be usable as a statement
property.type.infer=The type of the property '%s' could not be inferred
property.empty=The property '%s' cannot have neither a getter nor a setter
property.type.void=The property '%s' cannot have the type 'void'

# Fields

field.type=Field Type: %s
field.type.incompatible=The initial value of the field '%s' is incompatible with the field type
field.type.infer=The type of the field '%s' could not be inferred
field.type.infer.novalue=The type of the uninitialized field '%s' could not be inferred
field.type.void=Fields cannot have the type void
field.type.no_default=The type of the uninitialized field '%s' does not have a default value
field.property.setter.final=The final field '%s' cannot define a default property setter
field.enum.class=The enclosing class of the enum constant '%s' must be an enum class
field.enum.type.incompatible=The type of the enum constant '%s' must be a sub-type of the enclosing class type

field.access.invisible=The field '%s' cannot be accessed because it is not visible
field.access.internal=The internal field '%s' cannot be accessed because it is private to it's library
field.access.instance=The instance field '%s' cannot be accessed from a static context
field.access.static=The static field '%s' must be accessed in a static way
field.access.static.type=The static field '%1$s' of type '%2$s' should be accessed from that type
field.access.receiver_type=The receiver for the instance field '%s' incompatible with the required receiver type
field.access.unqualified=The instance field '%s' should be qualified with 'this'
field.access.unresolved_type=The type of the field '%s' is unresolved
field.assign.type=The type of the assigned value is incompatible with the type of the field '%s'
field.assign.final=The final field '%s' cannot be assigned

# Variables

variable.uninitialized=The variable '%s' has to be declared with an initial value
variable.shadow=The variable '%s' shadows another variable with the same name declared earlier
variable.type=Variable Type: %s
variable.type.incompatible=The initial value of the variable '%s' is incompatible with the variable type
variable.type.infer=The type of the variable '%s' could not be inferred
variable.type.void=Variables cannot have the type void
variable.assign.type=The type of the assigned value is incompatible with the type of the variable '%s'
variable.assign.final=The final variable '%s' cannot be assigned

variable.access.capture=The parameter '%s' cannot be accessed in this context because it is neither final nor \
  effectively final and cannot be converted to a Reference Variable
variable.assign.capture=The parameter '%s' cannot be assigned as it cannot be converted to a Reference Variable

# References

reference.expression.invalid=The expression cannot be referenced
reference.field.final=The final field '%s' cannot be converted to a reference
reference.property.no_setter=The property '%s' cannot be converted to a reference because it doesn't have a setter
reference.variable.invalid=The %s cannot be converted to a reference
reference.variable.assignment=The %s cannot be assigned because it cannot be converted to a reference

# Deprecation

deprecated.since=Deprecated Since: %s
deprecated.forRemoval=Scheduled for Removal: %s
deprecated.description=Description: %s
deprecated.replacements=Replacements:
deprecated.reason=Reason: %s
deprecated.reasons=Reasons: %s
deprecated.reason.DANGEROUS=dangerous
deprecated.reason.CONDEMNED=condemned
deprecated.reason.SUPERSEDED=superseded
deprecated.reason.UNIMPLEMENTED=unimplemented

experimental.description=Description: %s
experimental.stage=Stage: %s
experimental.stage.DANGEROUS=Dangerous
experimental.stage.UNSTABLE=Unstable
experimental.stage.UNRECOMMENDED=Unrecommended
experimental.stage.BETA=Beta
experimental.stage.ALPHA=Alpha
experimental.stage.PRERELEASE=Pre-release

# Expressions

value.type=Value Type: %s
expression.type=Expression Type: %s
receiver.type=Receiver Type: %s

operator.declaration=Operator Declaration: %s
operator.unresolved='%s' could not be resolved to an operator
operator.invalid_position=The %2$s operator '%s' should not be used in %3$s position
operator.infix_none=The infix operator '%s' without associativity cannot be used in this position

this.assign=Cannot assign a value to 'this'
this.access.unresolved=Cannot resolve contextual type of 'this' expression
this.access.static='this' cannot be accessed in a static context
this.instance=No enclosing instance for '%s' available

super.assign=Cannot assign a value to 'super'
super.access.static='super' cannot be accessed in a static context
super.access.type='super' cannot be accessed: The enclosing type does not have a super type
super.type.invalid=The requested super type is not a super type of the enclosing type
super.type.enclosing=The requested super type cannot be the enclosing type
super.type.indirect=The requested super type is not a direct super type of the enclosing type
super.type.interface.info=This access can be made valid by adding '%1$s' as a super-interface for '%2$s'
super.type.requested=Requested Super Type: %s

# Casts

cast.type.invalid=Invalid Cast - Missing target type
cast.value.invalid=Invalid Cast - Missing left-hand expression
cast.unnecessary=Unnecessary Cast - The expression already has the target type '%1$s'
cast.incompatible=Invalid Cast - The expression of type '%1$s' cannot be casted to '%2$s' because the types are not \
  related (neither is a sub- or super-type of the other)
cast.optional.primitive=Invalid Cast - The expression of type '%1$s' cannot be optional-casted to '%2$s', optional casts \
  cannot involve primitive types

# Instance Checks

instanceof.type.invalid=Invalid Instance Check - Missing query type
instanceof.value.invalid=Invalid Instance Check - Missing left-hand expression
instanceof.value.primitive=Invalid Instance Check - The expression must not have a primitive type
instanceof.type.primitive=Invalid Instance Check - The query type must not be a primitive type
instanceof.type.equal=Unnecessary Instance Check - The expression of type '%1$s' is always of type '%1$s' because they \
  are the same types
instanceof.type.subtype=Unnecessary Instance Check - The expression of type '%1$s' is always of type '%2$s' because \
  '%1$s' is a sub-type of '%2$s'
instanceof.type.incompatible=Invalid Instance Check - The expression of type '%1$s' can never be of type '%2$s' because \
  '%1$s' and '%2$s' are not related (neither is a sub- or super-type of the other)

# Array Literals

array.void=Cannot create an array with element type 'void'
array.element.type.expected=Expected Element Type: %s
array.element.type.actual=Actual Element Type: %s
array.element.type.incompatible=The array element type is incompatible with the array type

map.key.side_effects=Map Expression Keys should not have side effects
map.key.duplicate=Duplicate Map Key '%s'
map.key.type.expected=Expected Key Type: %s
map.key.type.actual=Actual Key Type: %s
map.key.type.incompatible=The key type is incompatible with the required key type
map.value.type.expected=Expected Key Type: %s
map.value.type.actual=Actual Key Type: %s
map.value.type.incompatible=The value type is incompatible with the required value type

tuple.element.type.expected=Expected Tuple Element Type: %s
tuple.element.type.actual=Actual Tuple Element Type: %s
tuple.element.type.incompatible=The tuple type is incompatible with the required tuple type

lambda.parameter.type=The type of the Lambda Parameter '%s' could not be inferred
lambda.parameter.implicit=The type of the implicit Lambda Parameter could not be inferred
lambda.method=The Lambda Expression could not be linked to a functional method
lambda.value.type.incompatible=The Lambda Return Value is incompatible with it's Return Type
lambda.value.invalid=Invalid Lambda Expression - Missing return value
lambda.return_type.incompatible=The explicit Lambda Return Type is incompatible with the actual return type
lambda.return_type.infer=The return type of the Lambda Expression could not be inferred
lambda.return_type=Lambda Return Type: %s

wildcard.type=Wildcard Target Type: %s
wildcard.type.unresolved=The Wildcard Literal cannot be used where no type is expected
wildcard.type.no_default=The Wildcard Literal cannot be used in place of a type without a default value

string.interpolation.void=The String Interpolation argument cannot be of type void
string.concat.void=Expressions of type void cannot be part of String Concatenation Chains

colon_operator.left.type=The left value of the colon operator is incompatible with the expected type
colon_operator.left.invalid=Invalid Colon Operator - Missing left value
colon_operator.right.type=The right value of the colon operator is incompatible with the expected type
colon_operator.right.invalid=Invalid Colon Operator - Missing right value

classoperator.invalid=Invalid Class Operator - Type expected
typeoperator.invalid=Invalid Type Operator - Type expected
nullcheck.primitive=Cannot perform a Null Pointer Check on a primitive value
varargs.invalid=The Varargs Expansion Operator can only be used in place of Varargs Parameters

range.type=Range Type: %s
range.start.type=The type of the range start is incompatible with the required type
range.end.type=The type of the range end is incompatible with the required type
range.element.type.incompatible=The element type of the range operator cannot be used for ranges, only numeric types \
  and subtypes of dyvil.collection.range.Rangeable are allowed
range.element.type=Range Element Type: %s

optional.unwrap.type.invalid=The type of the optional unwrap receiver is incompatible with the expected type
optional.chain.invalid=Invalid Optional Chain Operator - Optional Chain Operators can only be used as the receiver of \
  an access expression
optional.chain.type.incompatible=The type of the optional chain receiver is incompatible with the expected type

# Patterns

case.invalid=Invalid Case Statement - Invalid Expression
match.condition.type=The condition of a Case Condition has to evaluate to a boolean value
match.value.type.incompatible=The type of the match case is incompatible with the return type of the match expression
match.case.duplicate=Duplicate Match Case with value '%s'

pattern.type=Pattern Type: %s
pattern.type.incompatible=The type of the pattern is incompatible with the matched value type
pattern.dead=Unreachable Pattern
pattern.object=The class '%s' cannot be used as an Object Class Pattern
pattern.unapply.count=The Case Class Pattern for '%s' has an invalid number of patterns
pattern.unapply.count.class=Class Parameter Count: %s
pattern.unapply.count.pattern=Pattern Count: %s
pattern.unapply.type=The pattern is incompatible with the parameter type
pattern.tuple.element.type=The tuple pattern type is incompatible with the required tuple type
pattern.typecheck.invalid=Invalid Type Check pattern - Type expected

# Statements

if.condition.type=The Condition of an If Statement has to evaluate to a boolean value
if.condition.missing=Invalid If Statement - Missing Condition
if.then.type=The type of the then branch is incompatible with the required type
if.then.missing=Invalid If Statement - Missing Then Branch
if.else.type=The type of the else branch is incompatible with the required type
if.binding.nonnull=The Binding If Statement cannot be used with a value of a non-nullable type

while.action.type=The action of a While Statement has to be usable as a statement
while.condition.type=The condition of While Statement has to evaluate to a boolean value
while.condition.invalid=Invalid While Statement - Missing Condition

repeat.action.type=The action of a Repeat Statement has to be usable as a statement
repeat.condition.type=The condition of a Repeat Statement has to evaluate to a boolean value

# For Statements

for.condition.type=The condition of a For Statement has to evaluate to a boolean value
for.update.type=The update of a For Statement has to be usable as a statement
for.action.type=The action of a For Statement has to be usable as a statement

for.each.type=The iterated value of the For Each Statement is incompatible with the required type
for.each.invalid=Invalid For Each Statement - The expression cannot be iterated
for.variable.infer=The type of the loop variable '%s' could not be inferred
for.iterable.type=The element type of the Iterable is incompatible with the variable type
for.iterator.type=The element type of the Iterator is incompatible with the variable type
for.array.type=The element type of the iterated array is incompatible with the variable type
for.string.type=The type of the variable has to be 'char' when iterating over a String
for.range.type=The type of the iterated range is incompatible with the variable type

iterable.type=Iterable Type: %s
iterator.type=Iterator Type: %s

# Try / Catch Blocks

try.action.type.incompatible=The return type of the Try Block is incompatible with the required type
try.catch.type.not_throwable=The type of the Catch Block Variable must be a subtype of java.lang.Throwable
try.catch.type.incompatible=The return type of the Catch Block is incompatible with the required type
try.catch.type=Catch Block Type: %s
try.finally.type=The Finally Block of a Try Statement has to be usable as a statement

# Control Flow Statements

break.invalid=Invalid Break Statement: break cannot be used in this context
break.invalid.target=Invalid Break Statement: The statement labeled '%s' is not a loop
continue.invalid=Invalid Continue Statement: continue cannot be used in this context
continue.invalid.target=Invalid Continue Statement: The statement labeled '%s' is not a loop
goto.invalid=Invalid Goto Statement: goto cannot be used in this context
goto.warning=goto should not be used

return.void.invalid=Cannot return from a method with a return type other than 'void'
return.type.incompatible=The expression cannot be returned because it is incompatible with the return type of this context
return.type=Return Type: %s

# Misc.

value.constant=The expression could not be converted to a compile-time constant
value.constant.depth=Max. Constant Folding Depth: %d

literal.method=The literal conversion from %1$s to %2$s cannot be performed as the latter does not have a static %3$s method
literal.type.incompatible=The type of the literal conversion is incompatible with the required type
literal.type.conversion=Conversion Type: %s
literal.type.method=Conversion Method:\n\t\t%s

braceaccess.invalid=Invalid Brace Access - No implicit value in scope

throw.type=The value of the throw statement must be a subtype of java.lang.Throwable
statementlist.statement=A statement in a statement list has to be usable as such
statementlist.return=The return value of the statement list has to be usable as a statement
statementlist.declaration.invalid=The %s cannot be declared in this context

# Exceptions

exception.unhandled=Unhandled Exception type '%s'
exception.type=Exception Type: %s
