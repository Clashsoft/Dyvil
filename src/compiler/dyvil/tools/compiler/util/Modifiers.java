package dyvil.tools.compiler.util;

public enum Modifiers
{
	ACCESS, CLASS_TYPE, CLASS, MEMBER, FIELD_OR_METHOD, FIELD, METHOD, PARAMETER;
	
	public String toString(int mod)
	{
		StringBuilder sb = new StringBuilder();
		switch (this)
		{
		case ACCESS:
			writeAccessModifiers(mod, sb);
			break;
		case CLASS_TYPE:
			writeClassTypeModifiers(mod, sb);
			break;
		case CLASS:
			writeAccessModifiers(mod, sb);
			writeClassModifiers(mod, sb);
			break;
		case MEMBER:
		case FIELD_OR_METHOD:
			// Do not write any Modifiers as this should never be called
			break;
		case FIELD:
			writeAccessModifiers(mod, sb);
			writeFieldModifiers(mod, sb);
			break;
		case METHOD:
			writeAccessModifiers(mod, sb);
			writeMethodModifiers(mod, sb);
			break;
		case PARAMETER:
			writeParameterModifier(mod, sb);
			break;
		}
		return sb.toString();
	}
	
	public int parse(String mod)
	{
		int m = 0;
		switch (this)
		{
		case ACCESS:
			m = readAccessModifier(mod);
			break;
		case CLASS_TYPE:
			m = readClassTypeModifier(mod);
			break;
		case CLASS:
			if ((m = readAccessModifier(mod)) == -1)
			{
				m = readClassModifier(mod);
			}
			break;
		case MEMBER:
			if ((m = readAccessModifier(mod)) == -1)
			{
				if ((m = readClassModifier(mod)) == -1)
				{
					if ((m = readFieldModifier(mod)) == -1)
					{
						m = readMethodModifier(mod);
					}
				}
			}
			break;
		case FIELD_OR_METHOD:
			if ((m = readAccessModifier(mod)) == -1)
			{
				if ((m = readFieldModifier(mod)) == -1)
				{
					m = readMethodModifier(mod);
				}
			}
			break;
		case FIELD:
			if ((m = readAccessModifier(mod)) == -1)
			{
				m = readFieldModifier(mod);
			}
			break;
		case METHOD:
			if ((m = readAccessModifier(mod)) == -1)
			{
				m = readMethodModifier(mod);
			}
			break;
		case PARAMETER:
			if ((m = readAccessModifier(mod)) == -1)
			{
				m = readParameterModifier(mod);
			}
			break;
		}
		return m;
	}
	
	public static final int	PACKAGE					= 0x00000000;
	public static final int	PUBLIC					= 0x00000001;
	public static final int	PRIVATE					= 0x00000002;
	public static final int	PROTECTED				= 0x00000004;
	
	/**
	 * Dyvil derived access modifier.
	 */
	public static final int	DERIVED					= PRIVATE | PROTECTED;
	
	public static final int	STATIC					= 0x00000008;
	public static final int	FINAL					= 0x00000010;
	
	/**
	 * Dyvil constant modifier. This modifier is just a shortcut for
	 * {@code static final}.
	 */
	public static final int	CONST					= STATIC | FINAL;
	
	public static final int	SYNCHRONIZED			= 0x00000020;
	public static final int	VOLATILE				= 0x00000040;
	public static final int	BRIDGE					= 0x00000040;
	public static final int	TRANSIENT				= 0x00000080;
	public static final int	VARARGS					= 0x00000080;
	public static final int	NATIVE					= 0x00000100;
	
	public static final int	INTERFACE_CLASS			= 0x00000200;
	public static final int	ABSTRACT				= 0x00000400;
	
	/**
	 * Strictfp modifier. This is used for classes and methods and marks that
	 * floating point numbers (floats and doubles) have to be handled specially.
	 */
	public static final int	STRICT					= 0x00000800;
	
	/**
	 * Synthetic modifier. This is used for fields and methods that are not
	 * present in the source code and generated by the compiler.
	 */
	public static final int	SYNTHETIC				= 0x00001000;
	// TODO Annotation Types
	public static final int	ANNOTATION				= 0x00002000;
	// TODO Enums
	public static final int	ENUM					= 0x00004000;
	
	public static final int	MANDATED				= 0x00008000;
	
	// Field Modifiers
	
	/**
	 * Dyvil lazy modifier. If a field is marked with this modifier, it will be
	 * evaluated every time it is demanded and is thus not saved in the memory.
	 * This behavior can be compared with a method without parameters.
	 */
	public static final int	LAZY					= 0x00010000 | STATIC | FINAL;
	
	// Type Modifiers
	
	/**
	 * Dyvil object modifier. If a class is marked with this modifier, it is a
	 * singleton object class.
	 */
	public static final int	OBJECT_CLASS			= 0x00010000;
	
	/**
	 * Dyvil case modifier. If a class is marked with this modifier, it is a
	 * case class.
	 */
	public static final int	CASE_CLASS				= 0x00020000;
	
	/**
	 * Dyvil functional modifier. This modifier is a shortcut for the @FunctionalInterface
	 * annotation
	 */
	public static final int	FUNCTIONAL				= 0x00040000;
	
	// Method Modifiers
	
	/**
	 * Dyvil inline modifier. If a method is marked with this modifier, it will
	 * be inlined by the compiler to reduce method call overhead.
	 */
	// TODO inline Implementation
	public static final int	INLINE					= 0x00010000;
	
	/**
	 * Dyvil infix modifier. If a method is marked with this modifier, it is a
	 * method that can be called on any Object and virtually has the instance as
	 * the first parameter. An infix method is always static.
	 * 
	 * @see
	 */
	public static final int	INFIX					= 0x00020000 | STATIC;
	
	public static final int	PREFIX					= 0x00040000;
	
	/**
	 * Dyvil override modifier. This modifier is a shortcut for the @Override
	 * annotation.
	 */
	public static final int	OVERRIDE				= 0x00080000;
	
	// Parameter Modifiers
	
	/**
	 * Dyvil ref modifier. This is used to mark that a parameter is
	 * Call-By-Reference. If a parameter doesn't have this flag, it is
	 * Call-By-Value.
	 */
	// TODO byref Implementation
	public static final int	BYREF					= 0x00040000;
	
	// Member Modifiers
	
	/**
	 * Dyvil sealed modifier. This is used to mark that a class, method or field
	 * is only visible from inside the current library / project.
	 */
	public static final int	SEALED					= 0x00100000;
	
	/**
	 * Dyvil deprecated modifier. This modifier is a shortcut for the @Deprecated
	 * annotation.
	 */
	public static final int	DEPRECATED				= 0x00200000;
	
	public static final int	CLASS_TYPE_MODIFIERS	= INTERFACE_CLASS | ANNOTATION | ENUM | OBJECT_CLASS;
	public static final int	ACCESS_MODIFIERS		= PUBLIC | PROTECTED | PRIVATE | DEPRECATED | SEALED;
	public static final int	MEMBER_MODIFIERS		= ACCESS_MODIFIERS | DEPRECATED | STATIC | FINAL | SYNTHETIC;
	public static final int	CLASS_MODIFIERS			= MEMBER_MODIFIERS | ABSTRACT | STRICT | CASE_CLASS | FUNCTIONAL;
	
	public static final int	FIELD_MODIFIERS			= MEMBER_MODIFIERS | TRANSIENT | VOLATILE | LAZY;
	public static final int	METHOD_MODIFIERS		= MEMBER_MODIFIERS | SYNCHRONIZED | NATIVE | STRICT | INLINE | INFIX | PREFIX | DEPRECATED | BRIDGE
															| VARARGS | MANDATED;
	public static final int	PARAMETER_MODIFIERS		= FINAL | BYREF;
	
	private static void writeAccessModifiers(int mod, StringBuilder sb)
	{
		if ((mod & PUBLIC) == PUBLIC)
		{
			sb.append("public ");
		}
		
		if ((mod & DERIVED) == DERIVED)
		{
			sb.append("derived ");
		}
		else
		{
			if ((mod & PROTECTED) == PROTECTED)
			{
				sb.append("protected ");
			}
			if ((mod & PRIVATE) == PRIVATE)
			{
				sb.append("private ");
			}
		}
		
		if ((mod & DEPRECATED) == DEPRECATED)
		{
			sb.append("deprecated ");
		}
		if ((mod & SEALED) == SEALED)
		{
			sb.append("sealed ");
		}
	}
	
	private static void writeClassTypeModifiers(int mod, StringBuilder sb)
	{
		if (mod == 0)
		{
			sb.append("class ");
		}
		else if ((mod & INTERFACE_CLASS) == INTERFACE_CLASS)
		{
			sb.append("interface ");
		}
		else if ((mod & ANNOTATION) == ANNOTATION)
		{
			sb.append("annotation ");
		}
		else if ((mod & ENUM) == ENUM)
		{
			sb.append("enum ");
		}
		else if ((mod & OBJECT_CLASS) == OBJECT_CLASS)
		{
			sb.append("object ");
		}
		else
		{
			sb.append("class ");
		}
	}
	
	private static void writeClassModifiers(int mod, StringBuilder sb)
	{
		if ((mod & STATIC) == STATIC)
		{
			sb.append("static ");
		}
		if ((mod & ABSTRACT) == ABSTRACT)
		{
			sb.append("abstract ");
		}
		if ((mod & FINAL) == FINAL)
		{
			sb.append("final ");
		}
		if ((mod & STRICT) == STRICT)
		{
			sb.append("strictfp ");
		}
		if ((mod & FUNCTIONAL) == FUNCTIONAL)
		{
			sb.append("functional ");
		}
		if ((mod & CASE_CLASS) == CASE_CLASS)
		{
			sb.append("case ");
		}
	}
	
	private static void writeFieldModifiers(int mod, StringBuilder sb)
	{
		if ((mod & LAZY) == LAZY)
		{
			sb.append("lazy ");
		}
		else if ((mod & CONST) == CONST)
		{
			sb.append("const ");
		}
		else
		{
			if ((mod & STATIC) == STATIC)
			{
				sb.append("static ");
			}
			if ((mod & FINAL) == FINAL)
			{
				sb.append("final ");
			}
		}
		
		if ((mod & TRANSIENT) == TRANSIENT)
		{
			sb.append("transient ");
		}
		if ((mod & VOLATILE) == VOLATILE)
		{
			sb.append("volatile ");
		}
	}
	
	private static void writeMethodModifiers(int mod, StringBuilder sb)
	{
		if ((mod & INFIX) == INFIX)
		{
			sb.append("infix ");
		}
		else if ((mod & STATIC) == STATIC)
		{
			sb.append("static ");
		}
		if ((mod & FINAL) == FINAL)
		{
			sb.append("final ");
		}
		if ((mod & PREFIX) == PREFIX)
		{
			sb.append("prefix ");
		}
		
		if ((mod & SYNCHRONIZED) == SYNCHRONIZED)
		{
			sb.append("synchronized ");
		}
		if ((mod & NATIVE) == NATIVE)
		{
			sb.append("native ");
		}
		if ((mod & ABSTRACT) == ABSTRACT)
		{
			sb.append("abstract ");
		}
		if ((mod & STRICT) == STRICT)
		{
			sb.append("strictfp ");
		}
		if ((mod & INLINE) == INLINE)
		{
			sb.append("inline ");
		}
		if ((mod & OVERRIDE) == OVERRIDE)
		{
			sb.append("override ");
		}
	}
	
	private static void writeParameterModifier(int mod, StringBuilder sb)
	{
		if ((mod & FINAL) == FINAL)
		{
			sb.append("final ");
		}
		if ((mod & BYREF) == BYREF)
		{
			sb.append("byref ");
		}
	}
	
	private static int readAccessModifier(String mod)
	{
		switch (mod)
		{
		case "package":
			return PACKAGE;
		case "public":
			return PUBLIC;
		case "private":
			return PRIVATE;
		case "protected":
			return PROTECTED;
		case "derived":
			return DERIVED;
		case "sealed":
			return SEALED;
		case "deprecated":
			return DEPRECATED;
		}
		return -1;
	}
	
	private static int readClassTypeModifier(String mod)
	{
		switch (mod)
		{
		case "class":
			return 0;
		case "interface":
			return INTERFACE_CLASS;
		case "annotation":
			return ANNOTATION;
		case "enum":
			return ENUM;
		case "object":
			return OBJECT_CLASS;
		}
		return -1;
	}
	
	private static int readClassModifier(String mod)
	{
		switch (mod)
		{
		case "static":
			return STATIC;
		case "abstract":
			return ABSTRACT;
		case "final":
			return FINAL;
		case "strictfp":
			return STRICT;
		case "functional":
			return FUNCTIONAL;
		case "case":
			return CASE_CLASS;
		}
		return -1;
	}
	
	private static int readFieldModifier(String mod)
	{
		switch (mod)
		{
		case "static":
			return STATIC;
		case "final":
			return FINAL;
		case "const":
			return CONST;
		case "transient":
			return TRANSIENT;
		case "volatile":
			return VOLATILE;
		case "lazy":
			return LAZY;
		}
		return -1;
	}
	
	private static int readMethodModifier(String mod)
	{
		switch (mod)
		{
		case "static":
			return STATIC;
		case "final":
			return FINAL;
		case "const":
			return CONST;
		case "synchronized":
			return SYNCHRONIZED;
		case "native":
			return NATIVE;
		case "abstract":
			return ABSTRACT;
		case "strictfp":
			return STRICT;
		case "inline":
			return INLINE;
		case "infix":
			return INFIX;
		case "override":
			return OVERRIDE;
		}
		return -1;
	}
	
	private static int readParameterModifier(String mod)
	{
		switch (mod)
		{
		case "final":
			return FINAL;
		case "byref":
			return BYREF;
		}
		return -1;
	}
}
