package dyvil.experimental

public class EnumTest
{
	// ------ Example 1 ------

	enum Color
	{
		case Red
		case Green
		case Blue
	}

	// becomes

	public final class Color extends Enum<Color>
	{
		public enum const Red   = new Color("Red", 0)
		public enum const Green = new Color("Green", 1)
		public enum const Blue  = new Color("Blue", 2)

		const $VALUES: [final Color] = [Red, Green, Blue]

		const valueSet: ImmutableSet<Color> = EnumSet(class<Color>)
		{ public get }

		static func values() -> [final Color] = $VALUES.clone()

		@BytecodeName("valueOf")
		static func from(name: String) -> Color = Enum.valueOf(class<Color>, name)

		@BytecodeName("valueOf")
		static func from(id: int) -> Color = $VALUES[id]

		protected init(name: String, id: int)
		{
			super.init(name, id)
		}
	}

	// ------ Example 2 ------

	public enum Option<T>
	{
		case None
		case Some(let value: T)
	}

	// becomes

	public final class Option<T> extends Enum<Option<T>>
	{
		public enum const None = new Option(name: "None", id: 0)

		case class Some<T>(let value: T) extends Option(name: "Some", id: 1)

		private const $VALUES: [Option] = [None] // only non-parametric values are the "enum constants"

		// ... Rest as above
	}

	// ------ Example 3 ------

	@LiteralConvertible.FromInt
	public enum MyEnum(var value: int)
	{
		case Foo = 0
		case Bar = 10
		case Baz = 100
	}

	// becomes

	@LiteralConvertible.FromInt
	public enum MyEnum
	{
		case Foo = 1
		case Bar = 10
		case Baz = 100

		var value: int

		private init(value: int)
		{
			this.value = value
		}
	}

	// becomes

	@LiteralConvertible.FromInt
	public class MyEnum extends ...
	{
		public enum const Foo = new MyEnum("Foo", 0, value: 1)
		public enum const Bar = new MyEnum("Bar", 1, value: 10)
		public enum const Baz = new MyEnum("Baz", 2, value: 100)

		// ... Boilerplate as above

		var value: int

		private init(name: String, id: int, value: int)
		{
			super.init(name, id)
			this.value = value
		}
	}
}
