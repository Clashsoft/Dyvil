package dyvil.test

public class LambdaTest
{	
	functional trait Function[P, R]
	{
		public R apply(P par1)
		
		public Function[P, A] andThen[A](Function[R, A] other) = x => other(this(x))
	}
	
	functional interface IntFunction extends Function[int, int] {
		public override int apply(int value)
	}
	
	private static int staticSum = 0
	
	public static void main([String] args)
	{
		basicTest()
		chainTest()
		closureTest()
		compoundAssignmentTest()
		customSAMTest()
		partialFunctionTest()
	}
	
	private static void basicTest() {
		auto expected = [ 1 : "A", 10 : "a", 2 : "B", 20 : "b" ]
		auto map = [ 1 : "a", 2 : "b" ].flatMapped((i, s) => [ (i, s.toUpperCase), (i * 10, s) ])

		Main.test("Basic Lambda", map, expected)
	}
	
	private static void chainTest() {
		auto fun1 = (int i) => i + 1
		auto fun2 = (int i) => i * 2
		auto fun12 = fun1 andThen fun2
		auto result = (fun12(7))

		Main.test("Function Chain", 16, result)
	}
	
	private static void compoundAssignmentTest() {
		int localSum = 0
		auto list = List(1, 2, 3)
		list.forEach(i => localSum += i)
		list.forEach(i => staticSum += i)

		Main.test("Compound Assignment (Local)", 6, localSum)
		Main.test("Compound Assignment (Static)", 6, staticSum)
	}
	
	private static void customSAMTest() {
		IntFunction intF = i => i * i
		int result = intF(7)

		Main.test("Custom SAM Interface", 49, result)
	}

	private static void closureTest() {
		List[String] result = List.[String]

		() => void function1 = function { result += "a" }
		() => String function2 = function { "b" }

		repeat(3) { result += function2() }

		with ("c") { result += $0 }

		function1()

		List[String] expected = [ "b", "b", "b", "c", "a" ]
		Main.test("Closures", expected, result)
	}

	private static void partialFunctionTest() {
		(int, int) => int compareInts = _ compareTo _
		any => void printFun1 = Main.test("Partial Function Test 1", -1, _)

		printFun1(compareInts(1, 2))

		with ("A", Main.test("Partial Function Test 2", "A", _))
	}
}
