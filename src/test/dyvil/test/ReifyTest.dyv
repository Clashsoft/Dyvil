package dyvil.test

import dyvilx.lang.model.`type`.Type

type SL = List<String>

public class ReifyTest
{
	public static void main([String] args)
	{
		typeTest()
		classTest()
		classErasureTest()
		overrideTest()
	}

	// Reify Type
	private static Type<T> typeOf<@Reified(Reified.Type.TYPE) T>() = type T

	// Reify Type, with Argument
	private static Type<T> typeOf<@Reified(Reified.Type.TYPE) T>(T value) = type T

	// Reify Class
	private static Class<T> classOf<@Reified(Reified.Type.TYPE) T>() = class T

	// Reify Class, with Argument
	private static Class<T> classOf<@Reified(Reified.Type.TYPE) T>(T value) = class T

	// Reify Class from Erasure
	private static Class<T> classOfErasure<@Reified(Reified.Type.ANY_CLASS) T>() = class T

	// Reify Class from Erasure, with Argument
	private static Class<T> classOfErasure<@Reified(Reified.Type.ANY_CLASS) T>(T value) = class T

	private static void typeTest()
	{
		Type<SL> slType = type SL

		Type<SL> type1 = ReifyTest.typeOf<SL>
		Type<SL> type2 = ReifyTest.typeOf(List("a", "b", "c") as SL)

		Main.test("Reify Type Test", type1, slType, type1.toString == slType.toString)
		Main.test("Reity Type Test with Argument", type2, slType, type2.toString == slType.toString)
	}

	private static void classTest()
	{
		Class<String> stringClass = class String

		Class<String> class1 = ReifyTest.classOf<String>
		Class<String> class2 = ReifyTest.classOf "abc"

		Main.test("Reify Class Test", class1, stringClass)
		Main.test("Reify Class Test with Argument", class2, stringClass)
	}

	private static void classErasureTest()
	{
		Class<String> stringClass = class String

		Class<String> class1 = ReifyTest.classOfErasure<String>
		Class<String> class2 = ReifyTest.classOfErasure "abc"

		Main.test("Reify Erasure Class Test", class1, stringClass)
		Main.test("Reify Erasure Class Test with Argument", class2, stringClass)
	}

	class Base
	{
		func foo<@Reified(Reified.Type.TYPE)         T> : Object = type<T>
		func bar<@Reified(Reified.Type.ANY_CLASS)    T> : Object = class<T>
		func baz<@Reified(Reified.Type.OBJECT_CLASS) T> : Object = class<T>

		func moo: Object = new Object
	}

	class Derived1 extends Base
	{
		override func foo<@Reified(Reified.Type.ANY_CLASS) T> : Object = class<T>
		override func bar<@Reified(Reified.Type.TYPE)      T> : Object = type<T>
		override func baz<@Reified(Reified.Type.TYPE)      T> : Object = type<T>

		// T should become Object when called from super
		override func moo<@Reified(Reified.Type.TYPE)      T> : Object = type<T>
	}

	class Derived2 extends Base
	{
		override func foo<@Reified(Reified.Type.OBJECT_CLASS) T> : Object = class<T>
		override func bar<@Reified(Reified.Type.OBJECT_CLASS) T> : Object = class<T>
		override func baz<@Reified(Reified.Type.ANY_CLASS)    T> : Object = class<T>

		// T should become Object when called from super
		override func moo<@Reified(Reified.Type.ANY_CLASS)    T> : Object = class<T>
	}

	private static void overrideTest()
	{
		Base b1 = new Derived1
		Base b2 = new Derived2

		Main.testString("Reify Override Test 1.1", class<String>, b1.foo<String>)
		Main.testString("Reify Override Test 1.2", type<String>,  b1.bar<String>)
		Main.testString("Reify Override Test 1.3", type<String>,  b1.baz<String>)
		Main.testString("Reify Override Test 1.4", type<Object>,  b1.moo)

		Main.testString("Reify Override Test 2.1", class<String>, b2.foo<String>)
		Main.testString("Reify Override Test 2.2", class<String>, b2.bar<String>)
		Main.testString("Reify Override Test 2.3", class<String>, b2.baz<String>)
		Main.testString("Reify Override Test 2.4", class<Object>, b2.moo)
	}
}
