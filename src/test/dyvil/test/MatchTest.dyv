package dyvil.test

using dyvil.Collections

public class MatchTest
{
	public static void main([String] args)
	{
		table()
		tableHoles()
		lookup()
		stringTable()
		stringLookup()
		stringCollision()
		expression()
		tuples()
		caseClasses()
		objects()
		fields()
		orPatterns()
		andPatterns()
	}
	
	private static void table()
	{
		var value: String! = null

		1 match {
			case 0 => value = "zero"
			case 1 => value = "one"
			case 2 => value = "two"
			case _ => value = "else"
		}

		Main.test("Match -> TableSwitch", "one", value)
	}
	
	private static void tableHoles()
	{
		var value: String! = null

		2 match {
			case 0 => value = "null"
			case 1 => value = "one"
			case 2 => value = "two"
			case 5 => value = "five"
			case 6 => value = "six"
		}

		Main.test("Match -> TableSwitch (with holes)", "two", value)
	}
	
	private static void lookup()
	{
		var value: String! = null

		10 match {
			case 1   => value = "1"
			case 10  => value = "10"
			case 100 => value = "100"
			case _   => value = "something else"
		}

		Main.test("Match -> LookupSwitch", "10", value)
	}

	private static void stringTable()
	{
		var value: String! = null

		"a" match {
			case "a" => value = "A"
			case "b" => value = "B"
			case "c" => value = "C"
			case _   => value = "..."
		}

		Main.test("Match String -> TableSwitch", "A", value)
	}
	
	private static void stringLookup()
	{
		var value: String! = null

		"abc" match {
			case "abc" => value = "ABC"
			case "def" => value = "DEF"
			case _     => value = "..."
		}
		
		Main.test("Match String -> LookupSwitch", "ABC", value)
	}
	
	private static void stringCollision()
	{
		var value = 0

		"AaBB" match {
			case "Aa"   => value = 1
			case "BB"   => value = 2
			case "AaAa" => value = 3
			case "BBBB" => value = 4
			case "BBAa" | "AaBB" => value = 5
			case "ABC"  => value = 6
			case "DEF"  => value = 7
			case _      =>
		}

		Main.test("Match String -> Collision", 5, value)
	}
	
	private static void expression()
	{
		let result = 10 match {
			case 0     => "a"
			case 1     => "b"
			case var x => x.toString
		}

		Main.test("Match Expression", "10", result)
	}

	private static void tuples()
	{
		var value: String! = null
		var tuple = (1, 2)

		tuple match {
			case (0, _) => value = "(0, _)"
			case (_, 0) => value = "(_, 0)"
			case _		=> value = tuple.toString
		}

		Main.test("Match Tuples", value, tuple.toString)
	}

	private static void caseClasses()
	{
		{
			let option = Option 1
			var value = 0

			option match {
				case Some(int i) => value = i
				case _			 => value = -1
			}

			Main.test("Match Case Classes (primitive)", 1, value)
		}

		// ------------------------------------------------------------

		{
			let option = Option "abc"
			var value: String! = null

			option match {
				case Some(String s) => value = s
				case _				=> value = null
			}

			Main.test("Match Case Classes (Object)", "abc", value)
		}

		// ------------------------------------------------------------

		{
			let option = Option 2
			var value = 0

			option match {
				case Some(int i) => value = i
				case _			 => value = -1
			}

			Main.test("Match Case Classes (primitive 2)", 2, value)
		}
	}

	private static void objects()
	{
		let option = Option<int>()
		var value = 0

		option match {
			case None => value = 1
			case _	  => value = -1
		}

		Main.test("Match Objects", 1, value)
	}

	private const ERROR: int = 0
	private const SUCCESS: int = 1

	private const ERROR_BOXED: Int = ERROR

	private static void fields()
	{
		var value = 0

		// ------------------------------------------------------------

		SUCCESS match {
			case MatchTest.ERROR => value = ERROR
			case SUCCESS		 => value = SUCCESS
			case _			 	 => value = ERROR
		}

		Main.test("Match Fields", SUCCESS, value)

		// ------------------------------------------------------------

		ERROR_BOXED match {
			case ERROR => value = SUCCESS
			case _	   => value = ERROR
		}

		Main.test("Match Fields (Boxed -> Unboxed)", SUCCESS, value)

		// ------------------------------------------------------------

		ERROR match {
			case ERROR_BOXED => value = SUCCESS
			case _			 => value = ERROR
		}

		Main.test("Match Fields (Unboxed -> Boxed)", SUCCESS, value)

		// ------------------------------------------------------------

		(ERROR_BOXED as Object) match {
			case ERROR => value = SUCCESS
			case _	   => value = ERROR
		}

		Main.test("Match Fields (Object -> Unboxed)", SUCCESS, value)
	}

	private static void orPatterns()
	{
		let list = List<int>()

		for (int i <- 0 .. 10)
		{
			i match {
				case 1 | 2 | 3 => list += 0
				case 4 | 5 | 6 => list += 1
				case 7 | 8 | 9 => list += 2
				case 0 | 10	   => list += 3
			}
		}

		Main.test("Match OR Patterns", List(3, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3), list)
	}

	private static void andPatterns()
	{
		let tuple = (1, 2)
		var success = false

		tuple match {
			case (_, 2) & (1, _) => success = true
			case (1, _) & (_, 2) => success = true
			case _				 => success = false
		}

		Main.test("Match AND Patterns", success, true)
	}
}
