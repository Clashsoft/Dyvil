package dyvil.test

public interface Test
{
	public interface TestContainerBase
	{
		func addTest(Test test): void

		func applyStatement(Test test): void = this.addTest(test)
	}

	public case class TestContainer(
		public let name: String
	) implements Test, TestContainerBase
	{
		protected let subTests: List<Test> = MutableList<Test>

		public override func addTest(Test test): void = this.subTests.add(test)

		public override func passes(): boolean = this.subTests.allMatch(t => t.passes)

		public override func addErrors(List<String> errors): void
		{
			let subErrors = MutableList<String>
			for (subTest <- this.subTests)
			{
				if (!subTest.passes)
				{
					subTest.addErrors(subErrors)
				}
			}

			if (!subErrors.isEmpty)
			{
				errors.add("Test Collection '\(this.name)' failed:")
				for (subError <- subErrors)
				{
					errors.add('\t' + subError)
				}
			}
		}
	}

	static func test(String name, Configure<TestContainerBase> configure): TestContainer
	{
		let container = new TestContainer(name)
		configure container
		return container
	}

	public static case class RequireTest(
		public let predicate: -> boolean
	) implements Test
	{
		public override func passes(): boolean = this.predicate.apply

		public override func addErrors(List<String> errors): void
		{
			errors.add("Generic Requirement failed")
		}
	}

	static func require(-> boolean predicate): RequireTest = RequireTest(predicate)

	public static case class EqualityTest(
		public let actual: Object!
		public let expected: Object!
	) implements Test
	{
		public override func passes(): boolean = [this.actual].deepEquals([this.expected])

		public override func addErrors(List<String> errors): void
		{
			if (this.passes) return

			errors.add("Equality Requirement failed")
			errors.add("\texpected: \(this.expected)")
			errors.add("\tactual:   \(this.actual)")
		}
	}

	infix func =?=(Object! lhs, Object! rhs): EqualityTest = EqualityTest(lhs, rhs)

	public static case class ExpectTest(
		public let block: -> void
		public let errors: Class<+Throwable>...
	) implements Test
	{
		public override func passes(): boolean
		{
			try
			{
				this.block()
			}
			catch (Throwable t)
			{
				for (e <- this.errors) if (e.isInstance(t)) return true
				throw t
			}
			return false
		}

		public override func addErrors(List<String> errors): void
		{
			if (this.passes) return

			errors.add("Throwable Test Failed: ")
			errors.add("\texpected: \(this.errors)")
		}
	}

	static func expect(Class<+Throwable>... errors, -> void from) = ExpectTest(from, errors...)

	func passes(): boolean

	func addErrors(List<String> errors): void
}
