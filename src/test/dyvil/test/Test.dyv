package dyvil.test

interface Test
{
	// Test Containers

	interface TestContainerBase
	{
		func add(test: Test) -> void

		func applyStatement(test: Test) -> void = this.add(test)
	}

	case class TestContainer(
		let name: String
	) implements Test, TestContainerBase
	{
		protected let subTests: List<Test> = MutableList<Test>()

		override func add(test: Test) -> void = this.subTests.add(test)

		override func passes() -> boolean = this.subTests.allMatch(_.passes())

		override func addErrors(errors: List<String>) -> void
		{
			let subErrors = MutableList<String>()
			for (subTest <- this.subTests)
			{
				subTest.addErrors(subErrors)
			}

			if (subErrors.isEmpty) return

			errors.add("Test Collection '\(this.name)' failed:")
			for (subError <- subErrors)
			{
				errors.add('\t' + subError)
			}
		}
	}

	static func test(name: String, configure: Configure<TestContainerBase>) -> TestContainer
		= new TestContainer(name).use(configure)

	// Boolean Requirement Tests

	static case class RequireTest(
		let predicate: -> boolean
	) implements Test
	{
		override func passes() -> boolean = this.predicate.apply()

		override func addErrors(errors: List<String>) -> void
		{
			if (this.passes) return
			errors.add("Generic Requirement failed")
		}
	}

	static func require(predicate: -> boolean) -> RequireTest = RequireTest(predicate)

	// Equality Tests

	static case class EqualityTest(
		let actual: Object!
		let expected: Object!
		let inverted: boolean = false
	) implements Test
	{
		override func passes() -> boolean = [this.actual].deepEquals([this.expected]) != this.inverted

		override func addErrors(errors: List<String>) -> void
		{
			if (this.passes) return

			if (this.inverted)
			{
				errors.add("Inequality Requirement failed")
				errors.add("\tfor value: \(this.expected)")
				return;
			}

			errors.add("Equality Requirement failed")
			errors.add("\texpected: \(this.expected)")
			errors.add("\tactual:   \(this.actual)")
		}
	}

	infix func =?=(lhs: Object!, rhs: Object!) -> EqualityTest = EqualityTest(lhs, rhs, false)

	infix func =!=(lhs: Object!, rhs: Object!) -> EqualityTest = EqualityTest(lhs, rhs, true)

	// Expect Throwable Tests

	static case class ExpectTest(
		let block: -> void
		let errors: Class<+Throwable>...
	) implements Test
	{
		override func passes() -> boolean
		{
			try
			{
				this.block.apply()
			}
			catch (Throwable t)
			{
				for (e <- this.errors) if (e.isInstance(t)) return true
				throw t
			}
			return false
		}

		override func addErrors(errors: List<String>) -> void
		{
			if (this.passes) return

			errors.add("Throwable Test Failed: ")
			errors.add("\texpected: \(this.errors)")
		}
	}

	static func expect(errors: Class<+Throwable>..., from: -> void) -> ExpectTest = ExpectTest(from, errors...)

	// Test Methods

	func passes() -> boolean

	func addErrors(errors: List<String>) -> void
}
