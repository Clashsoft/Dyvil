package dyvil.math

class Solver
{
	interface Context
	{
		func resolve(name: String) -> Expr
	}

	interface Expr
	{
		func solve(c: Context) -> Expr
	}

	case class Var(let name: String) implements Expr
	{
		override func solve(c: Context) -> Expr = c.resolve(this.name)
	}

	case class Const(let value: double) implements Expr
	{
		override func solve(c: Context) -> Expr = this
	}

	case class Add(let lhs: Expr, let rhs: Expr) implements Expr
	{
		override func solve(c: Context) -> Expr
		{
			let l = this.lhs.solve(c)
			let r = this.rhs.solve(c)

			(l, r) match {
				case (Const(0), _) => r
				case (_, Const(0)) => l

				case (Const(var x), Const(var y)) => return Const(x + y)
				case _ => return Add(l, r)
			}
		}
	}

	case class Multiply(let lhs: Expr, let rhs: Expr) implements Expr
	{
		override func solve(Context c) -> Expr
		{
			let l = this.lhs.solve(c)
			let r = this.rhs.solve(c)

			(l, r) match {
				case (Const(0), _) | (_, Const(0)) => Const(0)
				case (Const(1), _) => r
				case (_, Const(1)) => l

				case (Const(var x), Const(var y)) => return Const(x * y)
				case _ => return Multiply(l, r)
			}
		}
	}

	// ---

	static implicit func d2Const(d: double) -> Const = Const(d)

	static implicit func map2Context(map: Map<String, Expr>) -> Context = s => map.get(s)

	infix func +(lhs: Expr, rhs: Expr) -> Expr = Add(lhs, rhs)

	infix func *(lhs: Expr, rhs: Expr) -> Expr = Multiply(lhs, rhs)
}
