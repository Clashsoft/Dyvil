package dyvil.tests

import class dyvil.tests.CaseClassTest._

using dyvil.Collections
using dyvil.Test

class MatchTest
{
	static enum TestEnum
	{
		case A
		case B
		case Aa
		case BB
		case AaAa
		case AaBB
		case BBAa
		case BBBB
	}

	static class KeyValue
	{
		postfix func unapply(s: String) -> (String, String)?
		{
			let index = s.indexOf ':'
			if (index < 0) return null
			return (s.substring(0, index), s.substring(index + 1))
		}
	}

	static func apply() -> Test = test "Match Expressions" {
		mixedPrimitives()
		table()
		tableHoles()
		lookup()
		stringTable()
		stringLookup()
		stringCollision()
		expression()
		tuples()
		enums()
		caseClasses()
		objects()
		fields()
		orPatterns()
		andPatterns()
	}

	private static func mixedPrimitives() -> Test = test "Mixed Primitives" {
		/*
		test "Integer" {
			0 match {
				case 0 => pass
				case 1L => fail
				case 2F => fail
				case 3D => fail
			}
		}

		test "Long" {
			1L match {
				case 0 => fail
				case 1L => pass
				case 2F => fail
				case 3D => fail
			}
		}

		test "Float" {
			2F match {
				case 0 => fail
				case 1L => fail
				case 2F => pass
				case 3D => fail
			}
		}

		test "Double" {
			3D match {
				case 0 => fail
				case 1L => fail
				case 2F => fail
				case 3D => pass
			}
		}
		*/
	}

	private static func table() -> Test = test "Table Switch" {
		2 match {
			case 0 => fail
			case 1 => fail
			case 2 => pass
			case _ => fail
		}
	}

	private static func tableHoles() -> Test = test "Table Switch with Holes" {
		2 match {
			case 0 => fail
			case 1 => fail
			case 2 => pass
			case 5 => fail
			case 6 => fail
		}
	}

	private static func lookup() -> Test = test "Lookup Switch" {
		100 match {
			case 1   => fail
			case 10  => fail
			case 100 => pass
			case _   => fail
		}
	}

	private static func stringTable() -> Test = test "Table Switch String" {
		"a" match {
			case "b" => fail
			case "c" => fail
			case "a" => pass
			case _   => fail
		}
	}

	private static func stringLookup() -> Test = test "Lookup Switch String" {
		"abc" match {
			case "def" => fail
			case "abc" => pass
			case _     => fail
		}
	}

	private static func stringCollision() -> Test = test "String Hash Collisions" {
		"AaBB" match {
			case "Aa"   => fail
			case "BB"   => fail
			case "AaAa" => fail
			case "BBBB" => fail
			case "BBAa" | "AaBB" => pass
			case "ABC"  => fail
			case "DEF"  => fail
			case _      => fail
		}
	}

	private static func expression() -> Test = test "Expressions" {
		let result = 10 match {
			case 0     => "a"
			case 1     => "b"
			case var x => x.toString
		}

		result =?= "10"
	}

	private static func tuples() -> Test = test "Tuples" {
		var tuple = (1, 2)

		tuple match {
			case (0, _) => fail
			case (_, 0) => fail
			case (1, 3) => fail
			case (2, 2) => fail
			case (1, 2) => pass
			case _      => fail
		}
	}

	private static func enums() -> Test = test "Enums" {
		match (TestEnum.BBAa)
		{
			case TestEnum.A => fail
			case TestEnum.B => fail
			case .Aa        => fail
			case .AaAa      => fail
			case .AaBB      => fail
			case .BB        => fail
			case .BBAa      => pass
			case .BBBB      => fail
			case _          => fail
		}
	}

	private static func caseClasses() -> Test = test "Case Classes" {
		test "Primitive" {
			let option = Option(1)
			var value: int = 0

			option match {
				case Some(var i) => value = i // ensure correct type
				case _	         => value = -1
			}

			value =?= 1
		}

		test "String" {
			let option = Option("abc")
			var value: String = ""

			option match {
				case Some(var s) => value = s // ensure correct type
				case _           => value = ""
			}

			value =?= "abc"
		}

		test "Case Classes" {
			let person = Person(0L, "Peter", 30, 1.8)
			let student = Student(1L, "John", 20, 1.85, "CS", 123456L)

			// destructure -> recreate -> check for equality
			person match case Person(var id, var name, var age, var height)
			{
				Person(id, name, age, height) =?= person
			}

			student match case Student(var id, var name, var age, var height, var faculty, var studentID)
			{
				Student(id, name, age, height, faculty, studentID) =?= student
			}
		}

		test "Optimized" {
			let tree: Tree<String> = Node("a", Leaf("b"), Leaf("c"))

			match (tree)
			{
				case Leaf(var s) => fail
				case Node("a", Leaf("b"), Leaf("c")) => pass
				case _ => fail
			}
		}

		test "Custom" {
			var key: String! = null
			var value: String! = null

			"abc:def" match case KeyValue(var k, var v)
			{
				key = k
				value = v
			}

			key =?= "abc"
			value =?= "def"
		}
	}

	private static func objects() -> Test = test "Objects" {
		let option = Option<int>()

		option match {
			case None => pass
			case _    => fail
		}
	}

	private const ERROR: int = 0
	private const SUCCESS: int = 1

	private const ERROR_BOXED: Int = ERROR

	private static func fields() -> Test = test "Fields" {
		var value = 0

		SUCCESS match {
			case MatchTest.ERROR => value = ERROR
			case SUCCESS         => value = SUCCESS
			case _               => value = ERROR
		}

		value =?= SUCCESS

		test "Unboxing" {
			ERROR_BOXED match {
				case ERROR => value = SUCCESS
				case _     => value = ERROR
			}

			value =?= SUCCESS
		}

		test "Boxing" {
			ERROR match {
				case ERROR_BOXED => value = SUCCESS
				case _           => value = ERROR
			}

			value =?= SUCCESS
		}

		test "Object Unboxing" {
			(ERROR_BOXED as Object) match {
				case ERROR => value = SUCCESS
				case _     => value = ERROR
			}

			value =?= SUCCESS
		}
	}

	private static func orPatterns() -> Test = test "OR Patterns" {
		let list = List<int>()

		for (i <- 0 .. 10)
		{
			match (i)
			{
				case 1 | 2 | 3 => list += 0
				case 4 | 5 | 6 => list += 1
				case 7 | 8 | 9 => list += 2
				case 0 | 10	   => list += 3
			}
		}

		list =?= List(3, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3)
	}

	private static func andPatterns() -> Test = test "AND Patterns" {
		let tuple = (1, 2)

		tuple match {
			case (_, 2) & (1, _) => pass
			case _ => fail
		}

		tuple match {
			case (1, _) & (_, 2) => pass
			case _ => fail
		}
	}
}
