package dyvil.tests

using dyvil.Test

class VirtualStaticTest
{
	interface Interface<T>
	{
		static func foo() -> T
		static func bar(v: T) -> T
	}

	static class Base implements Interface<String>
	{
		override static func foo() -> String = "Base"
		override static func bar(v: String) -> String = v ++ "_Base"
	}

	static class Derived extends Base
	{
		override static func foo() -> String = "Derived"
		override static func bar(v: String) -> String = v ++ "_Derived"
	}

	static func getFoo<type T, @Reified(.ANY_CLASS) type ITF: Interface<T>>() -> T = ITF.foo()

	static func getBar<type T, @Reified(.ANY_CLASS) type ITF: Interface<T>>(v: T) -> T = ITF.bar(v)

	// Apply Methods

	interface IntConstructible
	{
		static func apply(i: int) -> IntConstructible
	}

	static case class CustomInt(public let value: int) implements IntConstructible
	static case class MyInt    (public let value: int) implements IntConstructible

	static func create<@Reified(Reified.Type.TYPE) T: IntConstructible>(i: int) -> T = T(i) as T

	// Test

	static func apply() -> Test = test "Virtual Static Methods" {
		expect(class AbstractMethodError, from: => getFoo<Object, Interface<Object>>()) // see #379
		expect(class AbstractMethodError, from: => getBar<Object, Interface<Object>>(""))

		getFoo<String, Base>() =?= "Base"
		getFoo<String, Derived>() =?= "Derived"
		getBar<String, Base>("") =?= "_Base"
		getBar<String, Derived>("") =?= "_Derived"

		expect(class AbstractMethodError, from: => create<IntConstructible>(10))

		let customInt = create<CustomInt>(10)
		let myInt = create<MyInt>(20)

		customInt.value =?= 10
		myInt.value =?= 20
	}
}
