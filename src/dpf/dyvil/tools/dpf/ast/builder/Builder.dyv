package dyvil.tools.dpf.ast.builder;

import dyvil.collection.mutable.ArrayList
import dyvil.tools.{
	dpf.ast.{ Expandable, Node, value.Value }
	dpf.visitor.{ BuilderVisitor, NodeVisitor, ValueVisitor }

	parsing.{ Name, ast.IASTNode, position.ICodePosition }
}

public class Builder(
	private var name: Name! { public get; public set }
	private var parameters: List<Parameter>
	private var node: Node? { public get }
) implements Value, BuilderVisitor, Expandable
{
	static func apply(Name name) -> Builder = new Builder(name)

	static func apply(Name name, Parameter... parameters) -> Builder = new Builder(name, ArrayList(parameters...), null)

	static func apply(Name name, List<Parameter> parameters, Node! node = null) -> Builder = new Builder(name, parameters, node)
	
	public init(Name name)
	{
		this.init(name, new ArrayList<Parameter>, null)
	}

	@BytecodeName("withNode")
	public func with(Node node) -> Builder { this.node = node; this }

	@BytecodeName("withParameter")
	public func with(Parameter parameter) -> Builder { this.add(parameter); this }

	@BytecodeName("addParameter")
	public func add(Parameter parameter) -> void = this.parameters.add(parameter)

	@Deprecated(replacements: [ "Builder.visitNode() -> Node" ])
	public func makeNode() -> Node = this.visitNode

	override func visitParameter(Name! name) -> ValueVisitor = new Parameter(name).{ this.add($0); $0 }

	override func visitNode() -> Node
	{
		if (this.node != null) return this.node!!
		return this.node = new Node(this.name)
	}
	
	override func visitEnd() -> void { }
	
	override func accept(ValueVisitor visitor) -> void
	{
		let builderVisitor = visitor.visitBuilder(this.name)
		for (parameter <- this.parameters)
		{
			parameter.value.accept(builderVisitor.visitParameter(parameter.name))
		}
		if (this.node != null)
		{
			this.node!.acceptBody(builderVisitor.visitNode())
		}
		builderVisitor.visitEnd()
	}

	override func expand(Map<String, Object> mappings, boolean mutate) -> Builder
	{
		if (mutate)
		{
			for (parameter <- this.parameters)
			{
				parameter.expand(mappings, true)
			}
			if (this.node != null)
			{
				this.node = this.node!.expand(mappings, true)
			}
			return this
		}

		return new Builder(this.name
		                   this.parameters.mapped(parameter => parameter.expand(mappings, false))
		                   this.node == null ? null : this.node!.expand(mappings, false))
	}

	override func toString() -> String = IASTNode.toString(this)
	
	override func toString(String indent, StringBuilder buffer) -> void
	{
		buffer.append(this.name)
		
		let parameterCount = this.parameters.size
		if (parameterCount > 0)
		{
			buffer.append('(')
			
			this.parameters[0].toString(indent, buffer)
			for (i <- 1 ..< parameterCount)
			{
				buffer.append(", ")
				this.parameters[i].toString(indent, buffer)
			}
			
			buffer.append(')')
		}
		else if (this.node == null)
		{
			buffer.append("()")
			return
		}
		
		if (this.node != null)
		{
			buffer.append(" {\n")
			this.node!.bodyToString(indent + '\t', buffer)
			buffer.append(indent).append('}')
		}
	}

	override func equals(Object! o) -> boolean
	{
		if (this === o) return true
		if (!(o is Builder)) return false

		let that = o as Builder
		return this.name === that.name && this.parameters == that.parameters && this.node == that.node
	}

	override func hashCode() -> int
	{
		var result = this.name.hashCode
		result = 31 * result + this.parameters.hashCode
		result = 31 * result + this.node.hashCode
		return result
	}
}
