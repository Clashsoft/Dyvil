package dyvil.tools.dpf.ast

import dyvil.tools.dpf.visitor.{ NodeVisitor, ValueVisitor }
import dyvil.tools.dpf.model.Expandable
import dyvil.source.position.SourcePosition
import dyvilx.tools.parsing.ASTNode

public class NodeAccess
(
	protected let name: Name { public override get }
)
implements dyvil.tools.dpf.model.NodeAccess, NodeElement
{
	protected var element: NodeElement! = null

	public init(name: Name, element: NodeElement) : this(name)
	{
		this.element = element
	}

	override func element() -> NodeElement = this.element!

	override func visitNode(name: Name) -> NodeVisitor
	{
		let node = new Node(name)
		this.element = node
		return node
	}

	override func visitProperty(name: Name) -> ValueVisitor
	{
		let property = new Property(name)
		this.element = property
		return property
	}

	override func visitNodeAccess(name: Name) -> NodeVisitor
	{
		let access = new NodeAccess(name)
		this.element = access
		return access
	}

	override func accept(visitor: NodeVisitor) -> void = this.element.accept(visitor.visitNodeAccess(this.name))

	override func expand(mappings: Map<String, Object>, mutate: boolean) -> NodeAccess
	{
		let nodeAccess = mutate ? this : new NodeAccess(this.name)
		nodeAccess.element = Expandable.expand(this.element, mappings, mutate) as NodeElement
		return nodeAccess
	}

	override func toString() -> String = format(this)

	override func toString(indent: String, buffer: StringBuilder) -> void
	{
		buffer.append(this.name).append('.')
		this.element.toString(indent, buffer)
	}

	override func equals(obj: any!) -> boolean = this === obj || obj is NodeAccess && this.equals(obj as NodeAccess)

	func equals(that: NodeAccess) -> boolean = this === that || this.name === that.name && this.element == that.element

	override func hashCode() -> int = 31 * this.name.hashCode + this.element.hashCode
}
