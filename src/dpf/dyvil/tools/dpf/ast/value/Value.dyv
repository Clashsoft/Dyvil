package dyvil.tools.dpf.ast.value

import dyvil.lang.LiteralConvertible

import dyvil.tools.dpf.DPFConvertible

import dyvil.collection.Collection
import dyvil.collection.Map
import dyvil.collection.immutable.ArrayMap

import dyvil.tools.dpf.ast.value._
import dyvil.tools.dpf.visitor.ValueVisitor
import dyvil.tools.parsing.Name
import dyvil.tools.parsing.ast.IASTNode
import dyvil.tools.parsing.position.ICodePosition

import java.lang.reflect.Array

@LiteralConvertible.FromInt
@LiteralConvertible.FromLong
@LiteralConvertible.FromFloat
@LiteralConvertible.FromDouble
@LiteralConvertible.FromChar
@LiteralConvertible.FromString
@LiteralConvertible.FromBoolean
@LiteralConvertible.FromStringInterpolation
@LiteralConvertible.FromArray
@LiteralConvertible.FromMap
public interface Value extends IASTNode
{
	// Conversion Methods

	static final func apply(Object value): Value = wrap(value)

	static final func apply(int literal): IntValue = IntValue(literal)

	static final func apply(long literal): LongValue = LongValue(literal)

	static final func apply(float literal): FloatValue = FloatValue(literal)

	static final func apply(double literal): DoubleValue = DoubleValue(literal)

	static final func apply(char literal): StringValue = StringValue(literal.toString)

	static final func apply(String literal): StringValue = StringValue(literal)

	static final func apply(Name literal): NameAccess = NameAccess(literal)

	static final func apply(boolean literal): NameAccess = NameAccess(Name.fromRaw(literal.toString))

	static final func apply(Value... elements): ListValue = ListValue(elements)

	static final func apply(Value... keys, Value... values): MapValue = new MapValue(new ArrayMap(keys, values))

	static final func apply(String base, Value... values): StringInterpolation
		= new StringInterpolation(base.split(@"\\\d+") as [String], values)

	static final func apply(String base, Object... values): StringInterpolation
		= new StringInterpolation(base.split(@"\\\d+") as [String], values)

	// Override Methods

	override func getPosition(): ICodePosition! = null

	override func setPosition(ICodePosition! position): void { }

	override func toString(String indent, StringBuilder buffer): void

	func accept(ValueVisitor visitor): void

	// Value Conversions

	static final func wrap(any! value): Value
	{
		if (value is Value) return value as Value

		let valueClass = value.dynamicClass

		if (valueClass === class String) return new StringValue(value as String) 
		if (valueClass === class Int) return new IntValue(value as Int) 
		if (valueClass === class Long) return new LongValue(value as Long) 
		if (valueClass === class Float) return new FloatValue(value as Float) 
		if (valueClass === class Double) return new DoubleValue(value as Double)
		if (valueClass === class Name) return NameAccess(value as Name)
		if (valueClass === class Boolean) return Value(value as boolean)

		if (value is DPFConvertible) return (value as DPFConvertible).toPropertyValue()
		if (value is Collection) return ListValue(value as Collection)
		if (value is Map) return MapValue(value as Map)
		if (value.getClass.isArray)
		{
			// Convert Arrays using Reflection
			let size = Array.getLength(value)
			let listValue = ListValue(size)

			for (i <- 0 ..< size)
			{
				listValue.add(value: wrap(Array.get(value, i)))
			}

			return listValue
		}

		throw new RuntimeException("Cannot convert instance of type \(valueClass) to a DPF Value")
	}
}
