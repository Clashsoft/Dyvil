package dyvil.tools.dpf

import dyvil.tools.parsing.Name
import dyvil.tools.dpf.ast._
import dyvil.tools.dpf.ast.builder._
import dyvil.tools.dpf.ast.value._

public class DPFSyntax
{
	/**
	 * Root Node
	 *
	 * dpf { ... }
	 */
	static func dpf(configure: Configure<RootNode>) -> RootNode = new RootNode().use(configure)

	/**
	 * Node creation
	 *
	 * "name" { ... }
	 */
	infix func apply(name: Name, configure: Configure<Node>) -> Node = new Node(name).use(configure)

	/**
	 * Nested Node creation
	 *
	 * "parent" {
	 *     "child" { ... }
	 * }
	 */
	infix func applyStatement(base: Node, node: Node) -> void = base.add(node)

	/**
	 * Property creation with Colon
	 *
	 * "name": value
	 */
	infix func applyStatement(base: Node, pair: (Name, Value)) -> void = base.add(new Property(pair._1, pair._2))

	/**
	 * Builder creation
	 *
	 * "Name"("value", "label": "value")
	 */
	infix func apply(name: Name, parameters: (Value | (Name, Value))...) -> Builder
	{
		let builder = new Builder(name)

		for (element <- parameters) element match
		{
			case let v: Value => builder.add(Parameter(v))
			case let p: (Name, Value) => builder.add(Parameter(p._1, p._2))
		}

		return builder
	}

	/**
	 * Builder node
	 *
	 * "Builder"(...) { ... }
	 */
	infix func apply(builder: Builder, configure: Configure<Node>) -> Builder
	{
		configure(builder.visitNode())
		return builder
	}
}
