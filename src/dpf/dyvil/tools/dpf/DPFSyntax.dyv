package dyvil.tools.dpf

import dyvil.tools.parsing.Name
import dyvil.tools.dpf.ast._
import dyvil.tools.dpf.ast.builder._
import dyvil.tools.dpf.ast.value._

public class DPFSyntax
{
	@LiteralConvertible.FromColonOperator
	public static class PropertyPair(public Name! name, public Value value)
	{
		public static func apply(Name! name, any value): PropertyPair = new PropertyPair(name, Value.wrap(value))
	}

	@LiteralConvertible.FromColonOperator
	public static class BuilderParameter extends PropertyPair
	{
		public static func apply(Name? name, any value): BuilderParameter = new BuilderParameter(name, Value.wrap(value))

		public static func apply(Name? name, Value value): BuilderParameter = new BuilderParameter(name, value)

        public static implicit func apply(any value): BuilderParameter = new BuilderParameter(null, Value.wrap(value))

		public static implicit func apply(Value value): BuilderParameter = new BuilderParameter(null, value)

        public init(Name? name, Value value)
		{
			super.init(name, value)
		}
	}

	public static func dpf(Configure<RootNode> configure): RootNode = new RootNode().use(configure)

	/**
	 * Node creation:
	 *
	 * "name" { ... }
	 */
	public infix func apply(Name name, Configure<Node> configure): Node = new Node(name).use(configure)

	/**
	 * Nested Node creation
	 *
	 * "parent" {
	 *     "child" { ... }
	 * }
	 */
	public infix func applyStatement(Node base, Node node): void = base.add(node)

	/**
	 * Property creation with Colon
	 * "name": value
	 */
	public infix func applyStatement(Node base, PropertyPair property): void
	{
		base.add(new Property(property.name, property.value))
	}

	public infix func apply(Builder builder, Configure<Node> configure): Builder
	{
		builder.makeNode().use(configure)
		return builder
	}

	public infix func apply(Name name, BuilderParameter... parameters): Builder
	{
		let builder = new Builder(name)

		for (var pair <- parameters)
		{
			builder.add(Parameter(pair.name, pair.value))
		}

		return builder
	}
}
